{"version":3,"sources":["index.js","lib/argparse.js","lib/argument_parser.js","lib/const.js","lib/utils.js","lib/action_container.js","lib/action/help.js","lib/action.js","lib/action/append.js","lib/action/append/constant.js","lib/action/count.js","lib/action/store.js","lib/action/store/constant.js","lib/action/store/true.js","lib/action/store/false.js","lib/action/version.js","lib/action/subparsers.js","lib/argument/error.js","lib/argument/group.js","lib/argument/exclusive.js","lib/help/formatter.js","lib/namespace.js","lib/help/added_formatters.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;AHUA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;ACFA,AJYA,ACHA,ACHA,ACHA;AELA,ADGA,AHSA,ACHA,ACHA;AELA,ADGA,AHSA,ACHA,ACHA;AELA,ADGA,AHSA,ACHA,ACHA;AGRA,ADGA,ADGA,AHSA,ACHA,ACHA;AGRA,ADGA,ADGA,AHSA,ACHA,ACHA;AGRA,ADGA,ADGA,AHSA,ACHA,ACHA;AGRA,ACHA,AFMA,ADGA,AHSA,ACHA,ACHA;AGRA,ACHA,AFMA,ADGA,AHSA,ACHA,ACHA;AGRA,ACHA,AFMA,ADGA,AHSA,ACHA,ACHA;AGRA,ACHA,ACHA,AHSA,ADGA,AHSA,ACHA,ACHA;AGRA,ACHA,ACHA,AHSA,ADGA,AHSA,ACHA,ACHA;AGRA,ACHA,ACHA,AHSA,ADGA,AHSA,ACHA,ACHA;AGRA,ACHA,ACHA,ACHA,AJYA,ADGA,AHSA,ACHA,ACHA;AGRA,ACHA,ACHA,ACHA,AJYA,ADGA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,ADGA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ANkBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,APqBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,APqBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,APqBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ARwBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ARwBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,ACHA,ARwBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,ARwBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,ARwBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,ARwBA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AENA,AV8BA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AENA,AV8BA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AENA,AV8BA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AHSA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,Af6CA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,Af6CA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,Af6CA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,ACHA,AhBgDA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,ACHA,AhBgDA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,ACHA,AhBgDA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AENA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AkBtDA,AhBgDA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AkBtDA,AhBgDA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AkBtDA,AhBgDA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AkBtDA,ACHA,AjBmDA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AkBtDA,ACHA,AjBmDA;AGRA,ACHA,ACHA,ACHA,AJYA,AKfA,ACHA,AENA,ADGA,AGTA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AkBtDA,ACHA,AjBmDA;AGRA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA,AjBmDA;AGRA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA,AjBmDA;AGRA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA,AjBmDA;AGRA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,AENA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA,AjBmDA;AGRA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,ACHA,ACHA,AENA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,ACHA,ACHA,AENA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,ACHA,ACHA,AENA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,ACHA,ACHA,AENA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,ACHA,AGTA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,ACHA,AGTA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,ACHA,AGTA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AIZA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AIZA,ACHA,AIZA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AIZA,AKfA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AIZA,AKfA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AIZA,AKfA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AIZA,AKfA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,ADGA,AV8BA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AYpCA,AENA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,Ac1CA,ADGA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AavCA,AhBgDA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA,ACHA;Ad2CA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AoB5DA,AFMA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AbwCA,AS3BA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;AJaA,AXiCA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;Af8CA,AHSA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA,AkBtDA;AlBuDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nmodule.exports = require('./lib/argparse');\n","\n\nmodule.exports.ArgumentParser = require('./argument_parser.js');\nmodule.exports.Namespace = require('./namespace');\nmodule.exports.Action = require('./action');\nmodule.exports.HelpFormatter = require('./help/formatter.js');\nmodule.exports.Const = require('./const.js');\n\nmodule.exports.ArgumentDefaultsHelpFormatter =\n  require('./help/added_formatters.js').ArgumentDefaultsHelpFormatter;\nmodule.exports.RawDescriptionHelpFormatter =\n  require('./help/added_formatters.js').RawDescriptionHelpFormatter;\nmodule.exports.RawTextHelpFormatter =\n  require('./help/added_formatters.js').RawTextHelpFormatter;\n","/**\n * class ArgumentParser\n *\n * Object for parsing command line strings into js objects.\n *\n * Inherited from [[ActionContainer]]\n **/\n\n\nvar util    = require('util');\nvar format  = require('util').format;\nvar Path    = require('path');\nvar sprintf = require('sprintf-js').sprintf;\n\n// Constants\nvar c = require('./const');\n\nvar $$ = require('./utils');\n\nvar ActionContainer = require('./action_container');\n\n// Errors\nvar argumentErrorHelper = require('./argument/error');\n\nvar HelpFormatter = require('./help/formatter');\n\nvar Namespace = require('./namespace');\n\n\n/**\n * new ArgumentParser(options)\n *\n * Create a new ArgumentParser object.\n *\n * ##### Options:\n * - `prog`  The name of the program (default: Path.basename(process.argv[1]))\n * - `usage`  A usage message (default: auto-generated from arguments)\n * - `description`  A description of what the program does\n * - `epilog`  Text following the argument descriptions\n * - `parents`  Parsers whose arguments should be copied into this one\n * - `formatterClass`  HelpFormatter class for printing help messages\n * - `prefixChars`  Characters that prefix optional arguments\n * - `fromfilePrefixChars` Characters that prefix files containing additional arguments\n * - `argumentDefault`  The default value for all arguments\n * - `addHelp`  Add a -h/-help option\n * - `conflictHandler`  Specifies how to handle conflicting argument names\n * - `debug`  Enable debug mode. Argument errors throw exception in\n *   debug mode and process.exit in normal. Used for development and\n *   testing (default: false)\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects\n **/\nfunction ArgumentParser(options) {\n  if (!(this instanceof ArgumentParser)) {\n    return new ArgumentParser(options);\n  }\n  var self = this;\n  options = options || {};\n\n  options.description = (options.description || null);\n  options.argumentDefault = (options.argumentDefault || null);\n  options.prefixChars = (options.prefixChars || '-');\n  options.conflictHandler = (options.conflictHandler || 'error');\n  ActionContainer.call(this, options);\n\n  options.addHelp = typeof options.addHelp === 'undefined' || !!options.addHelp;\n  options.parents = options.parents || [];\n  // default program name\n  options.prog = (options.prog || Path.basename(process.argv[1]));\n  this.prog = options.prog;\n  this.usage = options.usage;\n  this.epilog = options.epilog;\n  this.version = options.version;\n\n  this.debug = (options.debug === true);\n\n  this.formatterClass = (options.formatterClass || HelpFormatter);\n  this.fromfilePrefixChars = options.fromfilePrefixChars || null;\n  this._positionals = this.addArgumentGroup({ title: 'Positional arguments' });\n  this._optionals = this.addArgumentGroup({ title: 'Optional arguments' });\n  this._subparsers = null;\n\n  // register types\n  function FUNCTION_IDENTITY(o) {\n    return o;\n  }\n  this.register('type', 'auto', FUNCTION_IDENTITY);\n  this.register('type', null, FUNCTION_IDENTITY);\n  this.register('type', 'int', function (x) {\n    var result = parseInt(x, 10);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid integer.');\n    }\n    return result;\n  });\n  this.register('type', 'float', function (x) {\n    var result = parseFloat(x);\n    if (isNaN(result)) {\n      throw new Error(x + ' is not a valid float.');\n    }\n    return result;\n  });\n  this.register('type', 'string', function (x) {\n    return '' + x;\n  });\n\n  // add help and version arguments if necessary\n  var defaultPrefix = (this.prefixChars.indexOf('-') > -1) ? '-' : this.prefixChars[0];\n  if (options.addHelp) {\n    this.addArgument(\n      [ defaultPrefix + 'h', defaultPrefix + defaultPrefix + 'help' ],\n      {\n        action: 'help',\n        defaultValue: c.SUPPRESS,\n        help: 'Show this help message and exit.'\n      }\n    );\n  }\n  if (typeof this.version !== 'undefined') {\n    this.addArgument(\n      [ defaultPrefix + 'v', defaultPrefix + defaultPrefix + 'version' ],\n      {\n        action: 'version',\n        version: this.version,\n        defaultValue: c.SUPPRESS,\n        help: \"Show program's version number and exit.\"\n      }\n    );\n  }\n\n  // add parent arguments and defaults\n  options.parents.forEach(function (parent) {\n    self._addContainerActions(parent);\n    if (typeof parent._defaults !== 'undefined') {\n      for (var defaultKey in parent._defaults) {\n        if (parent._defaults.hasOwnProperty(defaultKey)) {\n          self._defaults[defaultKey] = parent._defaults[defaultKey];\n        }\n      }\n    }\n  });\n}\n\nutil.inherits(ArgumentParser, ActionContainer);\n\n/**\n * ArgumentParser#addSubparsers(options) -> [[ActionSubparsers]]\n * - options (object): hash of options see [[ActionSubparsers.new]]\n *\n * See also [subcommands][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands\n **/\nArgumentParser.prototype.addSubparsers = function (options) {\n  if (this._subparsers) {\n    this.error('Cannot have multiple subparser arguments.');\n  }\n\n  options = options || {};\n  options.debug = (this.debug === true);\n  options.optionStrings = [];\n  options.parserClass = (options.parserClass || ArgumentParser);\n\n\n  if (!!options.title || !!options.description) {\n\n    this._subparsers = this.addArgumentGroup({\n      title: (options.title || 'subcommands'),\n      description: options.description\n    });\n    delete options.title;\n    delete options.description;\n\n  } else {\n    this._subparsers = this._positionals;\n  }\n\n  // prog defaults to the usage message of this parser, skipping\n  // optional arguments and with no \"usage:\" prefix\n  if (!options.prog) {\n    var formatter = this._getFormatter();\n    var positionals = this._getPositionalActions();\n    var groups = this._mutuallyExclusiveGroups;\n    formatter.addUsage(this.usage, positionals, groups, '');\n    options.prog = formatter.formatHelp().trim();\n  }\n\n  // create the parsers action and add it to the positionals list\n  var ParsersClass = this._popActionClass(options, 'parsers');\n  var action = new ParsersClass(options);\n  this._subparsers._addAction(action);\n\n  // return the created parsers action\n  return action;\n};\n\nArgumentParser.prototype._addAction = function (action) {\n  if (action.isOptional()) {\n    this._optionals._addAction(action);\n  } else {\n    this._positionals._addAction(action);\n  }\n  return action;\n};\n\nArgumentParser.prototype._getOptionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isOptional();\n  });\n};\n\nArgumentParser.prototype._getPositionalActions = function () {\n  return this._actions.filter(function (action) {\n    return action.isPositional();\n  });\n};\n\n\n/**\n * ArgumentParser#parseArgs(args, namespace) -> Namespace|Object\n * - args (array): input elements\n * - namespace (Namespace|Object): result object\n *\n * Parsed args and throws error if some arguments are not recognized\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method\n **/\nArgumentParser.prototype.parseArgs = function (args, namespace) {\n  var argv;\n  var result = this.parseKnownArgs(args, namespace);\n\n  args = result[0];\n  argv = result[1];\n  if (argv && argv.length > 0) {\n    this.error(\n      format('Unrecognized arguments: %s.', argv.join(' '))\n    );\n  }\n  return args;\n};\n\n/**\n * ArgumentParser#parseKnownArgs(args, namespace) -> array\n * - args (array): input options\n * - namespace (Namespace|Object): result object\n *\n * Parse known arguments and return tuple of result object\n * and unknown args\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing\n **/\nArgumentParser.prototype.parseKnownArgs = function (args, namespace) {\n  var self = this;\n\n  // args default to the system args\n  args = args || process.argv.slice(2);\n\n  // default Namespace built from parser defaults\n  namespace = namespace || new Namespace();\n\n  self._actions.forEach(function (action) {\n    if (action.dest !== c.SUPPRESS) {\n      if (!$$.has(namespace, action.dest)) {\n        if (action.defaultValue !== c.SUPPRESS) {\n          var defaultValue = action.defaultValue;\n          if (typeof action.defaultValue === 'string') {\n            defaultValue = self._getValue(action, defaultValue);\n          }\n          namespace[action.dest] = defaultValue;\n        }\n      }\n    }\n  });\n\n  Object.keys(self._defaults).forEach(function (dest) {\n    namespace[dest] = self._defaults[dest];\n  });\n\n  // parse the arguments and exit if there are any errors\n  try {\n    var res = this._parseKnownArgs(args, namespace);\n\n    namespace = res[0];\n    args = res[1];\n    if ($$.has(namespace, c._UNRECOGNIZED_ARGS_ATTR)) {\n      args = $$.arrayUnion(args, namespace[c._UNRECOGNIZED_ARGS_ATTR]);\n      delete namespace[c._UNRECOGNIZED_ARGS_ATTR];\n    }\n    return [ namespace, args ];\n  } catch (e) {\n    this.error(e);\n  }\n};\n\nArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {\n  var self = this;\n\n  var extras = [];\n\n  // replace arg strings that are file references\n  if (this.fromfilePrefixChars !== null) {\n    argStrings = this._readArgsFromFiles(argStrings);\n  }\n  // map all mutually exclusive arguments to the other arguments\n  // they can't occur with\n  // Python has 'conflicts = action_conflicts.setdefault(mutex_action, [])'\n  // though I can't conceive of a way in which an action could be a member\n  // of two different mutually exclusive groups.\n\n  function actionHash(action) {\n    // some sort of hashable key for this action\n    // action itself cannot be a key in actionConflicts\n    // I think getName() (join of optionStrings) is unique enough\n    return action.getName();\n  }\n\n  var conflicts, key;\n  var actionConflicts = {};\n\n  this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {\n    mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {\n      key = actionHash(mutexAction);\n      if (!$$.has(actionConflicts, key)) {\n        actionConflicts[key] = [];\n      }\n      conflicts = actionConflicts[key];\n      conflicts.push.apply(conflicts, groupActions.slice(0, i));\n      conflicts.push.apply(conflicts, groupActions.slice(i + 1));\n    });\n  });\n\n  // find all option indices, and determine the arg_string_pattern\n  // which has an 'O' if there is an option at an index,\n  // an 'A' if there is an argument, or a '-' if there is a '--'\n  var optionStringIndices = {};\n\n  var argStringPatternParts = [];\n\n  argStrings.forEach(function (argString, argStringIndex) {\n    if (argString === '--') {\n      argStringPatternParts.push('-');\n      while (argStringIndex < argStrings.length) {\n        argStringPatternParts.push('A');\n        argStringIndex++;\n      }\n    } else {\n      // otherwise, add the arg to the arg strings\n      // and note the index if it was an option\n      var pattern;\n      var optionTuple = self._parseOptional(argString);\n      if (!optionTuple) {\n        pattern = 'A';\n      } else {\n        optionStringIndices[argStringIndex] = optionTuple;\n        pattern = 'O';\n      }\n      argStringPatternParts.push(pattern);\n    }\n  });\n  var argStringsPattern = argStringPatternParts.join('');\n\n  var seenActions = [];\n  var seenNonDefaultActions = [];\n\n\n  function takeAction(action, argumentStrings, optionString) {\n    seenActions.push(action);\n    var argumentValues = self._getValues(action, argumentStrings);\n\n    // error if this argument is not allowed with other previously\n    // seen arguments, assuming that actions that use the default\n    // value don't really count as \"present\"\n    if (argumentValues !== action.defaultValue) {\n      seenNonDefaultActions.push(action);\n      if (actionConflicts[actionHash(action)]) {\n        actionConflicts[actionHash(action)].forEach(function (actionConflict) {\n          if (seenNonDefaultActions.indexOf(actionConflict) >= 0) {\n            throw argumentErrorHelper(\n              action,\n              format('Not allowed with argument \"%s\".', actionConflict.getName())\n            );\n          }\n        });\n      }\n    }\n\n    if (argumentValues !== c.SUPPRESS) {\n      action.call(self, namespace, argumentValues, optionString);\n    }\n  }\n\n  function consumeOptional(startIndex) {\n    // get the optional identified at this index\n    var optionTuple = optionStringIndices[startIndex];\n    var action = optionTuple[0];\n    var optionString = optionTuple[1];\n    var explicitArg = optionTuple[2];\n\n    // identify additional optionals in the same arg string\n    // (e.g. -xyz is the same as -x -y -z if no args are required)\n    var actionTuples = [];\n\n    var args, argCount, start, stop;\n\n    for (;;) {\n      if (!action) {\n        extras.push(argStrings[startIndex]);\n        return startIndex + 1;\n      }\n      if (explicitArg) {\n        argCount = self._matchArgument(action, 'A');\n\n        // if the action is a single-dash option and takes no\n        // arguments, try to parse more single-dash options out\n        // of the tail of the option string\n        var chars = self.prefixChars;\n        if (argCount === 0 && chars.indexOf(optionString[1]) < 0) {\n          actionTuples.push([ action, [], optionString ]);\n          optionString = optionString[0] + explicitArg[0];\n          var newExplicitArg = explicitArg.slice(1) || null;\n          var optionalsMap = self._optionStringActions;\n\n          if (Object.keys(optionalsMap).indexOf(optionString) >= 0) {\n            action = optionalsMap[optionString];\n            explicitArg = newExplicitArg;\n          } else {\n            throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n          }\n        } else if (argCount === 1) {\n          // if the action expect exactly one argument, we've\n          // successfully matched the option; exit the loop\n          stop = startIndex + 1;\n          args = [ explicitArg ];\n          actionTuples.push([ action, args, optionString ]);\n          break;\n        } else {\n          // error if a double-dash option did not use the\n          // explicit argument\n          throw argumentErrorHelper(action, sprintf('ignored explicit argument %r', explicitArg));\n        }\n      } else {\n        // if there is no explicit argument, try to match the\n        // optional's string arguments with the following strings\n        // if successful, exit the loop\n\n        start = startIndex + 1;\n        var selectedPatterns = argStringsPattern.substr(start);\n\n        argCount = self._matchArgument(action, selectedPatterns);\n        stop = start + argCount;\n\n\n        args = argStrings.slice(start, stop);\n\n        actionTuples.push([ action, args, optionString ]);\n        break;\n      }\n\n    }\n\n    // add the Optional to the list and return the index at which\n    // the Optional's string args stopped\n    if (actionTuples.length < 1) {\n      throw new Error('length should be > 0');\n    }\n    for (var i = 0; i < actionTuples.length; i++) {\n      takeAction.apply(self, actionTuples[i]);\n    }\n    return stop;\n  }\n\n  // the list of Positionals left to be parsed; this is modified\n  // by consume_positionals()\n  var positionals = self._getPositionalActions();\n\n  function consumePositionals(startIndex) {\n    // match as many Positionals as possible\n    var selectedPattern = argStringsPattern.substr(startIndex);\n    var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);\n\n    // slice off the appropriate arg strings for each Positional\n    // and add the Positional and its args to the list\n    for (var i = 0; i < positionals.length; i++) {\n      var action = positionals[i];\n      var argCount = argCounts[i];\n      if (typeof argCount === 'undefined') {\n        continue;\n      }\n      var args = argStrings.slice(startIndex, startIndex + argCount);\n\n      startIndex += argCount;\n      takeAction(action, args);\n    }\n\n    // slice off the Positionals that we just parsed and return the\n    // index at which the Positionals' string args stopped\n    positionals = positionals.slice(argCounts.length);\n    return startIndex;\n  }\n\n  // consume Positionals and Optionals alternately, until we have\n  // passed the last option string\n  var startIndex = 0;\n  var position;\n\n  var maxOptionStringIndex = -1;\n\n  Object.keys(optionStringIndices).forEach(function (position) {\n    maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));\n  });\n\n  var positionalsEndIndex, nextOptionStringIndex;\n\n  while (startIndex <= maxOptionStringIndex) {\n    // consume any Positionals preceding the next option\n    nextOptionStringIndex = null;\n    for (position in optionStringIndices) {\n      if (!optionStringIndices.hasOwnProperty(position)) { continue; }\n\n      position = parseInt(position, 10);\n      if (position >= startIndex) {\n        if (nextOptionStringIndex !== null) {\n          nextOptionStringIndex = Math.min(nextOptionStringIndex, position);\n        } else {\n          nextOptionStringIndex = position;\n        }\n      }\n    }\n\n    if (startIndex !== nextOptionStringIndex) {\n      positionalsEndIndex = consumePositionals(startIndex);\n      // only try to parse the next optional if we didn't consume\n      // the option string during the positionals parsing\n      if (positionalsEndIndex > startIndex) {\n        startIndex = positionalsEndIndex;\n        continue;\n      } else {\n        startIndex = positionalsEndIndex;\n      }\n    }\n\n    // if we consumed all the positionals we could and we're not\n    // at the index of an option string, there were extra arguments\n    if (!optionStringIndices[startIndex]) {\n      var strings = argStrings.slice(startIndex, nextOptionStringIndex);\n      extras = extras.concat(strings);\n      startIndex = nextOptionStringIndex;\n    }\n    // consume the next optional and any arguments for it\n    startIndex = consumeOptional(startIndex);\n  }\n\n  // consume any positionals following the last Optional\n  var stopIndex = consumePositionals(startIndex);\n\n  // if we didn't consume all the argument strings, there were extras\n  extras = extras.concat(argStrings.slice(stopIndex));\n\n  // if we didn't use all the Positional objects, there were too few\n  // arg strings supplied.\n  if (positionals.length > 0) {\n    self.error('too few arguments');\n  }\n\n  // make sure all required actions were present\n  self._actions.forEach(function (action) {\n    if (action.required) {\n      if (seenActions.indexOf(action) < 0) {\n        self.error(format('Argument \"%s\" is required', action.getName()));\n      }\n    }\n  });\n\n  // make sure all required groups have one option present\n  var actionUsed = false;\n  self._mutuallyExclusiveGroups.forEach(function (group) {\n    if (group.required) {\n      actionUsed = group._groupActions.some(function (action) {\n        return seenNonDefaultActions.indexOf(action) !== -1;\n      });\n\n      // if no actions were used, report the error\n      if (!actionUsed) {\n        var names = [];\n        group._groupActions.forEach(function (action) {\n          if (action.help !== c.SUPPRESS) {\n            names.push(action.getName());\n          }\n        });\n        names = names.join(' ');\n        var msg = 'one of the arguments ' + names + ' is required';\n        self.error(msg);\n      }\n    }\n  });\n\n  // return the updated namespace and the extra arguments\n  return [ namespace, extras ];\n};\n\nArgumentParser.prototype._readArgsFromFiles = function (argStrings) {\n  // expand arguments referencing files\n  var self = this;\n  var fs = require('fs');\n  var newArgStrings = [];\n  argStrings.forEach(function (argString) {\n    if (self.fromfilePrefixChars.indexOf(argString[0]) < 0) {\n      // for regular arguments, just add them back into the list\n      newArgStrings.push(argString);\n    } else {\n      // replace arguments referencing files with the file content\n      try {\n        var argstrs = [];\n        var filename = argString.slice(1);\n        var content = fs.readFileSync(filename, 'utf8');\n        content = content.trim().split('\\n');\n        content.forEach(function (argLine) {\n          self.convertArgLineToArgs(argLine).forEach(function (arg) {\n            argstrs.push(arg);\n          });\n          argstrs = self._readArgsFromFiles(argstrs);\n        });\n        newArgStrings.push.apply(newArgStrings, argstrs);\n      } catch (error) {\n        return self.error(error.message);\n      }\n    }\n  });\n  return newArgStrings;\n};\n\nArgumentParser.prototype.convertArgLineToArgs = function (argLine) {\n  return [ argLine ];\n};\n\nArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {\n\n  // match the pattern for this action to the arg strings\n  var regexpNargs = new RegExp('^' + this._getNargsPattern(action));\n  var matches = regexpArgStrings.match(regexpNargs);\n  var message;\n\n  // throw an exception if we weren't able to find a match\n  if (!matches) {\n    switch (action.nargs) {\n      /*eslint-disable no-undefined*/\n      case undefined:\n      case null:\n        message = 'Expected one argument.';\n        break;\n      case c.OPTIONAL:\n        message = 'Expected at most one argument.';\n        break;\n      case c.ONE_OR_MORE:\n        message = 'Expected at least one argument.';\n        break;\n      default:\n        message = 'Expected %s argument(s)';\n    }\n\n    throw argumentErrorHelper(\n      action,\n      format(message, action.nargs)\n    );\n  }\n  // return the number of arguments matched\n  return matches[1].length;\n};\n\nArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {\n  // progressively shorten the actions list by slicing off the\n  // final actions until we find a match\n  var self = this;\n  var result = [];\n  var actionSlice, pattern, matches;\n  var i, j;\n\n  function getLength(string) {\n    return string.length;\n  }\n\n  for (i = actions.length; i > 0; i--) {\n    pattern = '';\n    actionSlice = actions.slice(0, i);\n    for (j = 0; j < actionSlice.length; j++) {\n      pattern += self._getNargsPattern(actionSlice[j]);\n    }\n\n    pattern = new RegExp('^' + pattern);\n    matches = regexpArgStrings.match(pattern);\n\n    if (matches && matches.length > 0) {\n      // need only groups\n      matches = matches.splice(1);\n      result = result.concat(matches.map(getLength));\n      break;\n    }\n  }\n\n  // return the list of arg string counts\n  return result;\n};\n\nArgumentParser.prototype._parseOptional = function (argString) {\n  var action, optionString, argExplicit, optionTuples;\n\n  // if it's an empty string, it was meant to be a positional\n  if (!argString) {\n    return null;\n  }\n\n  // if it doesn't start with a prefix, it was meant to be positional\n  if (this.prefixChars.indexOf(argString[0]) < 0) {\n    return null;\n  }\n\n  // if the option string is present in the parser, return the action\n  if (this._optionStringActions[argString]) {\n    return [ this._optionStringActions[argString], argString, null ];\n  }\n\n  // if it's just a single character, it was meant to be positional\n  if (argString.length === 1) {\n    return null;\n  }\n\n  // if the option string before the \"=\" is present, return the action\n  if (argString.indexOf('=') >= 0) {\n    optionString = argString.split('=', 1)[0];\n    argExplicit = argString.slice(optionString.length + 1);\n\n    if (this._optionStringActions[optionString]) {\n      action = this._optionStringActions[optionString];\n      return [ action, optionString, argExplicit ];\n    }\n  }\n\n  // search through all possible prefixes of the option string\n  // and all actions in the parser for possible interpretations\n  optionTuples = this._getOptionTuples(argString);\n\n  // if multiple actions match, the option string was ambiguous\n  if (optionTuples.length > 1) {\n    var optionStrings = optionTuples.map(function (optionTuple) {\n      return optionTuple[1];\n    });\n    this.error(format(\n          'Ambiguous option: \"%s\" could match %s.',\n          argString, optionStrings.join(', ')\n    ));\n  // if exactly one action matched, this segmentation is good,\n  // so return the parsed action\n  } else if (optionTuples.length === 1) {\n    return optionTuples[0];\n  }\n\n  // if it was not found as an option, but it looks like a negative\n  // number, it was meant to be positional\n  // unless there are negative-number-like options\n  if (argString.match(this._regexpNegativeNumber)) {\n    if (!this._hasNegativeNumberOptionals.some(Boolean)) {\n      return null;\n    }\n  }\n  // if it contains a space, it was meant to be a positional\n  if (argString.search(' ') >= 0) {\n    return null;\n  }\n\n  // it was meant to be an optional but there is no such option\n  // in this parser (though it might be a valid option in a subparser)\n  return [ null, argString, null ];\n};\n\nArgumentParser.prototype._getOptionTuples = function (optionString) {\n  var result = [];\n  var chars = this.prefixChars;\n  var optionPrefix;\n  var argExplicit;\n  var action;\n  var actionOptionString;\n\n  // option strings starting with two prefix characters are only split at\n  // the '='\n  if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) >= 0) {\n    if (optionString.indexOf('=') >= 0) {\n      var optionStringSplit = optionString.split('=', 1);\n\n      optionPrefix = optionStringSplit[0];\n      argExplicit = optionStringSplit[1];\n    } else {\n      optionPrefix = optionString;\n      argExplicit = null;\n    }\n\n    for (actionOptionString in this._optionStringActions) {\n      if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        action = this._optionStringActions[actionOptionString];\n        result.push([ action, actionOptionString, argExplicit ]);\n      }\n    }\n\n  // single character options can be concatenated with their arguments\n  // but multiple character options always have to have their argument\n  // separate\n  } else if (chars.indexOf(optionString[0]) >= 0 && chars.indexOf(optionString[1]) < 0) {\n    optionPrefix = optionString;\n    argExplicit = null;\n    var optionPrefixShort = optionString.substr(0, 2);\n    var argExplicitShort = optionString.substr(2);\n\n    for (actionOptionString in this._optionStringActions) {\n      if (!$$.has(this._optionStringActions, actionOptionString)) continue;\n\n      action = this._optionStringActions[actionOptionString];\n      if (actionOptionString === optionPrefixShort) {\n        result.push([ action, actionOptionString, argExplicitShort ]);\n      } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {\n        result.push([ action, actionOptionString, argExplicit ]);\n      }\n    }\n\n  // shouldn't ever get here\n  } else {\n    throw new Error(format('Unexpected option string: %s.', optionString));\n  }\n  // return the collected option tuples\n  return result;\n};\n\nArgumentParser.prototype._getNargsPattern = function (action) {\n  // in all examples below, we have to allow for '--' args\n  // which are represented as '-' in the pattern\n  var regexpNargs;\n\n  switch (action.nargs) {\n    // the default (null) is assumed to be a single argument\n    case undefined:\n    case null:\n      regexpNargs = '(-*A-*)';\n      break;\n    // allow zero or more arguments\n    case c.OPTIONAL:\n      regexpNargs = '(-*A?-*)';\n      break;\n    // allow zero or more arguments\n    case c.ZERO_OR_MORE:\n      regexpNargs = '(-*[A-]*)';\n      break;\n    // allow one or more arguments\n    case c.ONE_OR_MORE:\n      regexpNargs = '(-*A[A-]*)';\n      break;\n    // allow any number of options or arguments\n    case c.REMAINDER:\n      regexpNargs = '([-AO]*)';\n      break;\n    // allow one argument followed by any number of options or arguments\n    case c.PARSER:\n      regexpNargs = '(-*A[-AO]*)';\n      break;\n    // all others should be integers\n    default:\n      regexpNargs = '(-*' + $$.repeat('-*A', action.nargs) + '-*)';\n  }\n\n  // if this is an optional action, -- is not allowed\n  if (action.isOptional()) {\n    regexpNargs = regexpNargs.replace(/-\\*/g, '');\n    regexpNargs = regexpNargs.replace(/-/g, '');\n  }\n\n  // return the pattern\n  return regexpNargs;\n};\n\n//\n// Value conversion methods\n//\n\nArgumentParser.prototype._getValues = function (action, argStrings) {\n  var self = this;\n\n  // for everything but PARSER args, strip out '--'\n  if (action.nargs !== c.PARSER && action.nargs !== c.REMAINDER) {\n    argStrings = argStrings.filter(function (arrayElement) {\n      return arrayElement !== '--';\n    });\n  }\n\n  var value, argString;\n\n  // optional argument produces a default when not present\n  if (argStrings.length === 0 && action.nargs === c.OPTIONAL) {\n\n    value = (action.isOptional()) ? action.constant : action.defaultValue;\n\n    if (typeof (value) === 'string') {\n      value = this._getValue(action, value);\n      this._checkValue(action, value);\n    }\n\n  // when nargs='*' on a positional, if there were no command-line\n  // args, use the default if it is anything other than None\n  } else if (argStrings.length === 0 && action.nargs === c.ZERO_OR_MORE &&\n    action.optionStrings.length === 0) {\n\n    value = (action.defaultValue || argStrings);\n    this._checkValue(action, value);\n\n  // single argument or optional argument produces a single value\n  } else if (argStrings.length === 1 &&\n        (!action.nargs || action.nargs === c.OPTIONAL)) {\n\n    argString = argStrings[0];\n    value = this._getValue(action, argString);\n    this._checkValue(action, value);\n\n  // REMAINDER arguments convert all values, checking none\n  } else if (action.nargs === c.REMAINDER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n\n  // PARSER arguments convert all values, but check only the first\n  } else if (action.nargs === c.PARSER) {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    this._checkValue(action, value[0]);\n\n  // all other types of nargs produce a list\n  } else {\n    value = argStrings.map(function (v) {\n      return self._getValue(action, v);\n    });\n    value.forEach(function (v) {\n      self._checkValue(action, v);\n    });\n  }\n\n  // return the converted value\n  return value;\n};\n\nArgumentParser.prototype._getValue = function (action, argString) {\n  var result;\n\n  var typeFunction = this._registryGet('type', action.type, action.type);\n  if (typeof typeFunction !== 'function') {\n    var message = format('%s is not callable', typeFunction);\n    throw argumentErrorHelper(action, message);\n  }\n\n  // convert the value to the appropriate type\n  try {\n    result = typeFunction(argString);\n\n    // ArgumentTypeErrors indicate errors\n    // If action.type is not a registered string, it is a function\n    // Try to deduce its name for inclusion in the error message\n    // Failing that, include the error message it raised.\n  } catch (e) {\n    var name = null;\n    if (typeof action.type === 'string') {\n      name = action.type;\n    } else {\n      name = action.type.name || action.type.displayName || '<function>';\n    }\n    var msg = format('Invalid %s value: %s', name, argString);\n    if (name === '<function>') { msg += '\\n' + e.message; }\n    throw argumentErrorHelper(action, msg);\n  }\n  // return the converted value\n  return result;\n};\n\nArgumentParser.prototype._checkValue = function (action, value) {\n  // converted value must be one of the choices (if specified)\n  var choices = action.choices;\n  if (choices) {\n    // choise for argument can by array or string\n    if ((typeof choices === 'string' || Array.isArray(choices)) &&\n        choices.indexOf(value) !== -1) {\n      return;\n    }\n    // choise for subparsers can by only hash\n    if (typeof choices === 'object' && !Array.isArray(choices) && choices[value]) {\n      return;\n    }\n\n    if (typeof choices === 'string') {\n      choices = choices.split('').join(', ');\n    } else if (Array.isArray(choices)) {\n      choices =  choices.join(', ');\n    } else {\n      choices =  Object.keys(choices).join(', ');\n    }\n    var message = format('Invalid choice: %s (choose from [%s])', value, choices);\n    throw argumentErrorHelper(action, message);\n  }\n};\n\n//\n// Help formatting methods\n//\n\n/**\n * ArgumentParser#formatUsage -> string\n *\n * Return usage string\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatUsage = function () {\n  var formatter = this._getFormatter();\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n  return formatter.formatHelp();\n};\n\n/**\n * ArgumentParser#formatHelp -> string\n *\n * Return help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.formatHelp = function () {\n  var formatter = this._getFormatter();\n\n  // usage\n  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);\n\n  // description\n  formatter.addText(this.description);\n\n  // positionals, optionals and user-defined groups\n  this._actionGroups.forEach(function (actionGroup) {\n    formatter.startSection(actionGroup.title);\n    formatter.addText(actionGroup.description);\n    formatter.addArguments(actionGroup._groupActions);\n    formatter.endSection();\n  });\n\n  // epilog\n  formatter.addText(this.epilog);\n\n  // determine help from format above\n  return formatter.formatHelp();\n};\n\nArgumentParser.prototype._getFormatter = function () {\n  var FormatterClass = this.formatterClass;\n  var formatter = new FormatterClass({ prog: this.prog });\n  return formatter;\n};\n\n//\n//  Print functions\n//\n\n/**\n * ArgumentParser#printUsage() -> Void\n *\n * Print usage\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printUsage = function () {\n  this._printMessage(this.formatUsage());\n};\n\n/**\n * ArgumentParser#printHelp() -> Void\n *\n * Print help\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#printing-help\n **/\nArgumentParser.prototype.printHelp = function () {\n  this._printMessage(this.formatHelp());\n};\n\nArgumentParser.prototype._printMessage = function (message, stream) {\n  if (!stream) {\n    stream = process.stdout;\n  }\n  if (message) {\n    stream.write('' + message);\n  }\n};\n\n//\n//  Exit functions\n//\n\n/**\n * ArgumentParser#exit(status=0, message) -> Void\n * - status (int): exit status\n * - message (string): message\n *\n * Print message in stderr/stdout and exit program\n **/\nArgumentParser.prototype.exit = function (status, message) {\n  if (message) {\n    if (status === 0) {\n      this._printMessage(message);\n    } else {\n      this._printMessage(message, process.stderr);\n    }\n  }\n\n  process.exit(status);\n};\n\n/**\n * ArgumentParser#error(message) -> Void\n * - err (Error|string): message\n *\n * Error method Prints a usage message incorporating the message to stderr and\n * exits. If you override this in a subclass,\n * it should not return -- it should\n * either exit or throw an exception.\n *\n **/\nArgumentParser.prototype.error = function (err) {\n  var message;\n  if (err instanceof Error) {\n    if (this.debug === true) {\n      throw err;\n    }\n    message = err.message;\n  } else {\n    message = err;\n  }\n  var msg = format('%s: error: %s', this.prog, message) + c.EOL;\n\n  if (this.debug === true) {\n    throw new Error(msg);\n  }\n\n  this.printUsage(process.stderr);\n\n  return this.exit(2, msg);\n};\n\nmodule.exports = ArgumentParser;\n","//\n// Constants\n//\n\n\n\nmodule.exports.EOL = '\\n';\n\nmodule.exports.SUPPRESS = '==SUPPRESS==';\n\nmodule.exports.OPTIONAL = '?';\n\nmodule.exports.ZERO_OR_MORE = '*';\n\nmodule.exports.ONE_OR_MORE = '+';\n\nmodule.exports.PARSER = 'A...';\n\nmodule.exports.REMAINDER = '...';\n\nmodule.exports._UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args';\n","\n\nexports.repeat = function (str, num) {\n  var result = '';\n  for (var i = 0; i < num; i++) { result += str; }\n  return result;\n};\n\nexports.arrayEqual = function (a, b) {\n  if (a.length !== b.length) { return false; }\n  for (var i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) { return false; }\n  }\n  return true;\n};\n\nexports.trimChars = function (str, chars) {\n  var start = 0;\n  var end = str.length - 1;\n  while (chars.indexOf(str.charAt(start)) >= 0) { start++; }\n  while (chars.indexOf(str.charAt(end)) >= 0) { end--; }\n  return str.slice(start, end + 1);\n};\n\nexports.capitalize = function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nexports.arrayUnion = function () {\n  var result = [];\n  for (var i = 0, values = {}; i < arguments.length; i++) {\n    var arr = arguments[i];\n    for (var j = 0; j < arr.length; j++) {\n      if (!values[arr[j]]) {\n        values[arr[j]] = true;\n        result.push(arr[j]);\n      }\n    }\n  }\n  return result;\n};\n\nfunction has(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nexports.has = has;\n\nexports.extend = function (dest, src) {\n  for (var i in src) {\n    if (has(src, i)) { dest[i] = src[i]; }\n  }\n};\n\nexports.trimEnd = function (str) {\n  return str.replace(/\\s+$/g, '');\n};\n","/** internal\n * class ActionContainer\n *\n * Action container. Parent for [[ArgumentParser]] and [[ArgumentGroup]]\n **/\n\n\n\nvar format = require('util').format;\n\n// Constants\nvar c = require('./const');\n\nvar $$ = require('./utils');\n\n//Actions\nvar ActionHelp = require('./action/help');\nvar ActionAppend = require('./action/append');\nvar ActionAppendConstant = require('./action/append/constant');\nvar ActionCount = require('./action/count');\nvar ActionStore = require('./action/store');\nvar ActionStoreConstant = require('./action/store/constant');\nvar ActionStoreTrue = require('./action/store/true');\nvar ActionStoreFalse = require('./action/store/false');\nvar ActionVersion = require('./action/version');\nvar ActionSubparsers = require('./action/subparsers');\n\n// Errors\nvar argumentErrorHelper = require('./argument/error');\n\n/**\n * new ActionContainer(options)\n *\n * Action container. Parent for [[ArgumentParser]] and [[ArgumentGroup]]\n *\n * ##### Options:\n *\n * - `description` -- A description of what the program does\n * - `prefixChars`  -- Characters that prefix optional arguments\n * - `argumentDefault`  -- The default value for all arguments\n * - `conflictHandler` -- The conflict handler to use for duplicate arguments\n **/\nvar ActionContainer = module.exports = function ActionContainer(options) {\n  options = options || {};\n\n  this.description = options.description;\n  this.argumentDefault = options.argumentDefault;\n  this.prefixChars = options.prefixChars || '';\n  this.conflictHandler = options.conflictHandler;\n\n  // set up registries\n  this._registries = {};\n\n  // register actions\n  this.register('action', null, ActionStore);\n  this.register('action', 'store', ActionStore);\n  this.register('action', 'storeConst', ActionStoreConstant);\n  this.register('action', 'storeTrue', ActionStoreTrue);\n  this.register('action', 'storeFalse', ActionStoreFalse);\n  this.register('action', 'append', ActionAppend);\n  this.register('action', 'appendConst', ActionAppendConstant);\n  this.register('action', 'count', ActionCount);\n  this.register('action', 'help', ActionHelp);\n  this.register('action', 'version', ActionVersion);\n  this.register('action', 'parsers', ActionSubparsers);\n\n  // raise an exception if the conflict handler is invalid\n  this._getHandler();\n\n  // action storage\n  this._actions = [];\n  this._optionStringActions = {};\n\n  // groups\n  this._actionGroups = [];\n  this._mutuallyExclusiveGroups = [];\n\n  // defaults storage\n  this._defaults = {};\n\n  // determines whether an \"option\" looks like a negative number\n  // -1, -1.5 -5e+4\n  this._regexpNegativeNumber = new RegExp('^[-]?[0-9]*\\\\.?[0-9]+([eE][-+]?[0-9]+)?$');\n\n  // whether or not there are any optionals that look like negative\n  // numbers -- uses a list so it can be shared and edited\n  this._hasNegativeNumberOptionals = [];\n};\n\n// Groups must be required, then ActionContainer already defined\nvar ArgumentGroup = require('./argument/group');\nvar MutuallyExclusiveGroup = require('./argument/exclusive');\n\n//\n// Registration methods\n//\n\n/**\n * ActionContainer#register(registryName, value, object) -> Void\n * - registryName (String) : object type action|type\n * - value (string) : keyword\n * - object (Object|Function) : handler\n *\n *  Register handlers\n **/\nActionContainer.prototype.register = function (registryName, value, object) {\n  this._registries[registryName] = this._registries[registryName] || {};\n  this._registries[registryName][value] = object;\n};\n\nActionContainer.prototype._registryGet = function (registryName, value, defaultValue) {\n  if (arguments.length < 3) {\n    defaultValue = null;\n  }\n  return this._registries[registryName][value] || defaultValue;\n};\n\n//\n// Namespace default accessor methods\n//\n\n/**\n * ActionContainer#setDefaults(options) -> Void\n * - options (object):hash of options see [[Action.new]]\n *\n * Set defaults\n **/\nActionContainer.prototype.setDefaults = function (options) {\n  options = options || {};\n  for (var property in options) {\n    if ($$.has(options, property)) {\n      this._defaults[property] = options[property];\n    }\n  }\n\n  // if these defaults match any existing arguments, replace the previous\n  // default on the object with the new one\n  this._actions.forEach(function (action) {\n    if ($$.has(options, action.dest)) {\n      action.defaultValue = options[action.dest];\n    }\n  });\n};\n\n/**\n * ActionContainer#getDefault(dest) -> Mixed\n * - dest (string): action destination\n *\n * Return action default value\n **/\nActionContainer.prototype.getDefault = function (dest) {\n  var result = $$.has(this._defaults, dest) ? this._defaults[dest] : null;\n\n  this._actions.forEach(function (action) {\n    if (action.dest === dest && $$.has(action, 'defaultValue')) {\n      result = action.defaultValue;\n    }\n  });\n\n  return result;\n};\n//\n// Adding argument actions\n//\n\n/**\n * ActionContainer#addArgument(args, options) -> Object\n * - args (String|Array): argument key, or array of argument keys\n * - options (Object): action objects see [[Action.new]]\n *\n * #### Examples\n * - addArgument([ '-f', '--foo' ], { action: 'store', defaultValue: 1, ... })\n * - addArgument([ 'bar' ], { action: 'store', nargs: 1, ... })\n * - addArgument('--baz', { action: 'store', nargs: 1, ... })\n **/\nActionContainer.prototype.addArgument = function (args, options) {\n  args = args;\n  options = options || {};\n\n  if (typeof args === 'string') {\n    args = [ args ];\n  }\n  if (!Array.isArray(args)) {\n    throw new TypeError('addArgument first argument should be a string or an array');\n  }\n  if (typeof options !== 'object' || Array.isArray(options)) {\n    throw new TypeError('addArgument second argument should be a hash');\n  }\n\n  // if no positional args are supplied or only one is supplied and\n  // it doesn't look like an option string, parse a positional argument\n  if (!args || args.length === 1 && this.prefixChars.indexOf(args[0][0]) < 0) {\n    if (args && !!options.dest) {\n      throw new Error('dest supplied twice for positional argument');\n    }\n    options = this._getPositional(args, options);\n\n    // otherwise, we're adding an optional argument\n  } else {\n    options = this._getOptional(args, options);\n  }\n\n  // if no default was supplied, use the parser-level default\n  if (typeof options.defaultValue === 'undefined') {\n    var dest = options.dest;\n    if ($$.has(this._defaults, dest)) {\n      options.defaultValue = this._defaults[dest];\n    } else if (typeof this.argumentDefault !== 'undefined') {\n      options.defaultValue = this.argumentDefault;\n    }\n  }\n\n  // create the action object, and add it to the parser\n  var ActionClass = this._popActionClass(options);\n  if (typeof ActionClass !== 'function') {\n    throw new Error(format('Unknown action \"%s\".', ActionClass));\n  }\n  var action = new ActionClass(options);\n\n  // throw an error if the action type is not callable\n  var typeFunction = this._registryGet('type', action.type, action.type);\n  if (typeof typeFunction !== 'function') {\n    throw new Error(format('\"%s\" is not callable', typeFunction));\n  }\n\n  return this._addAction(action);\n};\n\n/**\n * ActionContainer#addArgumentGroup(options) -> ArgumentGroup\n * - options (Object): hash of options see [[ArgumentGroup.new]]\n *\n * Create new arguments groups\n **/\nActionContainer.prototype.addArgumentGroup = function (options) {\n  var group = new ArgumentGroup(this, options);\n  this._actionGroups.push(group);\n  return group;\n};\n\n/**\n * ActionContainer#addMutuallyExclusiveGroup(options) -> ArgumentGroup\n * - options (Object): {required: false}\n *\n * Create new mutual exclusive groups\n **/\nActionContainer.prototype.addMutuallyExclusiveGroup = function (options) {\n  var group = new MutuallyExclusiveGroup(this, options);\n  this._mutuallyExclusiveGroups.push(group);\n  return group;\n};\n\nActionContainer.prototype._addAction = function (action) {\n  var self = this;\n\n  // resolve any conflicts\n  this._checkConflict(action);\n\n  // add to actions list\n  this._actions.push(action);\n  action.container = this;\n\n  // index the action by any option strings it has\n  action.optionStrings.forEach(function (optionString) {\n    self._optionStringActions[optionString] = action;\n  });\n\n  // set the flag if any option strings look like negative numbers\n  action.optionStrings.forEach(function (optionString) {\n    if (optionString.match(self._regexpNegativeNumber)) {\n      if (!self._hasNegativeNumberOptionals.some(Boolean)) {\n        self._hasNegativeNumberOptionals.push(true);\n      }\n    }\n  });\n\n  // return the created action\n  return action;\n};\n\nActionContainer.prototype._removeAction = function (action) {\n  var actionIndex = this._actions.indexOf(action);\n  if (actionIndex >= 0) {\n    this._actions.splice(actionIndex, 1);\n  }\n};\n\nActionContainer.prototype._addContainerActions = function (container) {\n  // collect groups by titles\n  var titleGroupMap = {};\n  this._actionGroups.forEach(function (group) {\n    if (titleGroupMap[group.title]) {\n      throw new Error(format('Cannot merge actions - two groups are named \"%s\".', group.title));\n    }\n    titleGroupMap[group.title] = group;\n  });\n\n  // map each action to its group\n  var groupMap = {};\n  function actionHash(action) {\n    // unique (hopefully?) string suitable as dictionary key\n    return action.getName();\n  }\n  container._actionGroups.forEach(function (group) {\n    // if a group with the title exists, use that, otherwise\n    // create a new group matching the container's group\n    if (!titleGroupMap[group.title]) {\n      titleGroupMap[group.title] = this.addArgumentGroup({\n        title: group.title,\n        description: group.description\n      });\n    }\n\n    // map the actions to their new group\n    group._groupActions.forEach(function (action) {\n      groupMap[actionHash(action)] = titleGroupMap[group.title];\n    });\n  }, this);\n\n  // add container's mutually exclusive groups\n  // NOTE: if add_mutually_exclusive_group ever gains title= and\n  // description= then this code will need to be expanded as above\n  var mutexGroup;\n  container._mutuallyExclusiveGroups.forEach(function (group) {\n    mutexGroup = this.addMutuallyExclusiveGroup({\n      required: group.required\n    });\n    // map the actions to their new mutex group\n    group._groupActions.forEach(function (action) {\n      groupMap[actionHash(action)] = mutexGroup;\n    });\n  }, this);  // forEach takes a 'this' argument\n\n  // add all actions to this container or their group\n  container._actions.forEach(function (action) {\n    var key = actionHash(action);\n    if (groupMap[key]) {\n      groupMap[key]._addAction(action);\n    } else {\n      this._addAction(action);\n    }\n  });\n};\n\nActionContainer.prototype._getPositional = function (dest, options) {\n  if (Array.isArray(dest)) {\n    dest = dest[0];\n  }\n  // make sure required is not specified\n  if (options.required) {\n    throw new Error('\"required\" is an invalid argument for positionals.');\n  }\n\n  // mark positional arguments as required if at least one is\n  // always required\n  if (options.nargs !== c.OPTIONAL && options.nargs !== c.ZERO_OR_MORE) {\n    options.required = true;\n  }\n  if (options.nargs === c.ZERO_OR_MORE && typeof options.defaultValue === 'undefined') {\n    options.required = true;\n  }\n\n  // return the keyword arguments with no option strings\n  options.dest = dest;\n  options.optionStrings = [];\n  return options;\n};\n\nActionContainer.prototype._getOptional = function (args, options) {\n  var prefixChars = this.prefixChars;\n  var optionStrings = [];\n  var optionStringsLong = [];\n\n  // determine short and long option strings\n  args.forEach(function (optionString) {\n    // error on strings that don't start with an appropriate prefix\n    if (prefixChars.indexOf(optionString[0]) < 0) {\n      throw new Error(format('Invalid option string \"%s\": must start with a \"%s\".',\n        optionString,\n        prefixChars\n      ));\n    }\n\n    // strings starting with two prefix characters are long options\n    optionStrings.push(optionString);\n    if (optionString.length > 1 && prefixChars.indexOf(optionString[1]) >= 0) {\n      optionStringsLong.push(optionString);\n    }\n  });\n\n  // infer dest, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n  var dest = options.dest || null;\n  delete options.dest;\n\n  if (!dest) {\n    var optionStringDest = optionStringsLong.length ? optionStringsLong[0] : optionStrings[0];\n    dest = $$.trimChars(optionStringDest, this.prefixChars);\n\n    if (dest.length === 0) {\n      throw new Error(\n        format('dest= is required for options like \"%s\"', optionStrings.join(', '))\n      );\n    }\n    dest = dest.replace(/-/g, '_');\n  }\n\n  // return the updated keyword arguments\n  options.dest = dest;\n  options.optionStrings = optionStrings;\n\n  return options;\n};\n\nActionContainer.prototype._popActionClass = function (options, defaultValue) {\n  defaultValue = defaultValue || null;\n\n  var action = (options.action || defaultValue);\n  delete options.action;\n\n  var actionClass = this._registryGet('action', action, action);\n  return actionClass;\n};\n\nActionContainer.prototype._getHandler = function () {\n  var handlerString = this.conflictHandler;\n  var handlerFuncName = '_handleConflict' + $$.capitalize(handlerString);\n  var func = this[handlerFuncName];\n  if (typeof func === 'undefined') {\n    var msg = 'invalid conflict resolution value: ' + handlerString;\n    throw new Error(msg);\n  } else {\n    return func;\n  }\n};\n\nActionContainer.prototype._checkConflict = function (action) {\n  var optionStringActions = this._optionStringActions;\n  var conflictOptionals = [];\n\n  // find all options that conflict with this option\n  // collect pairs, the string, and an existing action that it conflicts with\n  action.optionStrings.forEach(function (optionString) {\n    var conflOptional = optionStringActions[optionString];\n    if (typeof conflOptional !== 'undefined') {\n      conflictOptionals.push([ optionString, conflOptional ]);\n    }\n  });\n\n  if (conflictOptionals.length > 0) {\n    var conflictHandler = this._getHandler();\n    conflictHandler.call(this, action, conflictOptionals);\n  }\n};\n\nActionContainer.prototype._handleConflictError = function (action, conflOptionals) {\n  var conflicts = conflOptionals.map(function (pair) { return pair[0]; });\n  conflicts = conflicts.join(', ');\n  throw argumentErrorHelper(\n    action,\n    format('Conflicting option string(s): %s', conflicts)\n  );\n};\n\nActionContainer.prototype._handleConflictResolve = function (action, conflOptionals) {\n  // remove all conflicting options\n  var self = this;\n  conflOptionals.forEach(function (pair) {\n    var optionString = pair[0];\n    var conflictingAction = pair[1];\n    // remove the conflicting option string\n    var i = conflictingAction.optionStrings.indexOf(optionString);\n    if (i >= 0) {\n      conflictingAction.optionStrings.splice(i, 1);\n    }\n    delete self._optionStringActions[optionString];\n    // if the option now has no option string, remove it from the\n    // container holding it\n    if (conflictingAction.optionStrings.length === 0) {\n      conflictingAction.container._removeAction(conflictingAction);\n    }\n  });\n};\n","/*:nodoc:*\n * class ActionHelp\n *\n * Support action for printing help\n * This class inherided from [[Action]]\n **/\n\n\nvar util = require('util');\n\nvar Action = require('../action');\n\n// Constants\nvar c  = require('../const');\n\n/*:nodoc:*\n * new ActionHelp(options)\n * - options (object): options hash see [[Action.new]]\n *\n **/\nvar ActionHelp = module.exports = function ActionHelp(options) {\n  options = options || {};\n  if (options.defaultValue !== null) {\n    options.defaultValue = options.defaultValue;\n  } else {\n    options.defaultValue = c.SUPPRESS;\n  }\n  options.dest = (options.dest !== null ? options.dest : c.SUPPRESS);\n  options.nargs = 0;\n  Action.call(this, options);\n\n};\nutil.inherits(ActionHelp, Action);\n\n/*:nodoc:*\n * ActionHelp#call(parser, namespace, values, optionString)\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Print help and exit\n **/\nActionHelp.prototype.call = function (parser) {\n  parser.printHelp();\n  parser.exit();\n};\n","/**\n * class Action\n *\n * Base class for all actions\n * Do not call in your code, use this class only for inherits your own action\n *\n * Information about how to convert command line strings to Javascript objects.\n * Action objects are used by an ArgumentParser to represent the information\n * needed to parse a single argument from one or more strings from the command\n * line. The keyword arguments to the Action constructor are also all attributes\n * of Action instances.\n *\n * ##### Allowed keywords:\n *\n * - `store`\n * - `storeConstant`\n * - `storeTrue`\n * - `storeFalse`\n * - `append`\n * - `appendConstant`\n * - `count`\n * - `help`\n * - `version`\n *\n * Information about action options see [[Action.new]]\n *\n * See also [original guide](http://docs.python.org/dev/library/argparse.html#action)\n *\n **/\n\n\n\n\n// Constants\nvar c = require('./const');\n\n\n/**\n * new Action(options)\n *\n * Base class for all actions. Used only for inherits\n *\n *\n * ##### Options:\n *\n * - `optionStrings`  A list of command-line option strings for the action.\n * - `dest`  Attribute to hold the created object(s)\n * - `nargs`  The number of command-line arguments that should be consumed.\n * By default, one argument will be consumed and a single value will be\n * produced.\n * - `constant`  Default value for an action with no value.\n * - `defaultValue`  The value to be produced if the option is not specified.\n * - `type`  Cast to 'string'|'int'|'float'|'complex'|function (string). If\n * None, 'string'.\n * - `choices`  The choices available.\n * - `required`  True if the action must always be specified at the command\n * line.\n * - `help`  The help describing the argument.\n * - `metavar`  The name to be used for the option's argument with the help\n * string. If None, the 'dest' value will be used as the name.\n *\n * ##### nargs supported values:\n *\n * - `N` (an integer) consumes N arguments (and produces a list)\n * - `?`  consumes zero or one arguments\n * - `*` consumes zero or more arguments (and produces a list)\n * - `+` consumes one or more arguments (and produces a list)\n *\n * Note: that the difference between the default and nargs=1 is that with the\n * default, a single value will be produced, while with nargs=1, a list\n * containing a single value will be produced.\n **/\nvar Action = module.exports = function Action(options) {\n  options = options || {};\n  this.optionStrings = options.optionStrings || [];\n  this.dest = options.dest;\n  this.nargs = typeof options.nargs !== 'undefined' ? options.nargs : null;\n  this.constant = typeof options.constant !== 'undefined' ? options.constant : null;\n  this.defaultValue = options.defaultValue;\n  this.type = typeof options.type !== 'undefined' ? options.type : null;\n  this.choices = typeof options.choices !== 'undefined' ? options.choices : null;\n  this.required = typeof options.required !== 'undefined' ? options.required : false;\n  this.help = typeof options.help !== 'undefined' ? options.help : null;\n  this.metavar = typeof options.metavar !== 'undefined' ? options.metavar : null;\n\n  if (!(this.optionStrings instanceof Array)) {\n    throw new Error('optionStrings should be an array');\n  }\n  if (typeof this.required !== 'undefined' && typeof this.required !== 'boolean') {\n    throw new Error('required should be a boolean');\n  }\n};\n\n/**\n * Action#getName -> String\n *\n * Tells action name\n **/\nAction.prototype.getName = function () {\n  if (this.optionStrings.length > 0) {\n    return this.optionStrings.join('/');\n  } else if (this.metavar !== null && this.metavar !== c.SUPPRESS) {\n    return this.metavar;\n  } else if (typeof this.dest !== 'undefined' && this.dest !== c.SUPPRESS) {\n    return this.dest;\n  }\n  return null;\n};\n\n/**\n * Action#isOptional -> Boolean\n *\n * Return true if optional\n **/\nAction.prototype.isOptional = function () {\n  return !this.isPositional();\n};\n\n/**\n * Action#isPositional -> Boolean\n *\n * Return true if positional\n **/\nAction.prototype.isPositional = function () {\n  return (this.optionStrings.length === 0);\n};\n\n/**\n * Action#call(parser, namespace, values, optionString) -> Void\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Call the action. Should be implemented in inherited classes\n *\n * ##### Example\n *\n *      ActionCount.prototype.call = function (parser, namespace, values, optionString) {\n *        namespace.set(this.dest, (namespace[this.dest] || 0) + 1);\n *      };\n *\n **/\nAction.prototype.call = function () {\n  throw new Error('.call() not defined');// Not Implemented error\n};\n","/*:nodoc:*\n * class ActionAppend\n *\n * This action stores a list, and appends each argument value to the list.\n * This is useful to allow an option to be specified multiple times.\n * This class inherided from [[Action]]\n *\n **/\n\n\n\nvar util = require('util');\n\nvar Action = require('../action');\n\n// Constants\nvar c = require('../const');\n\n/*:nodoc:*\n * new ActionAppend(options)\n * - options (object): options hash see [[Action.new]]\n *\n * Note: options.nargs should be optional for constants\n * and more then zero for other\n **/\nvar ActionAppend = module.exports = function ActionAppend(options) {\n  options = options || {};\n  if (this.nargs <= 0) {\n    throw new Error('nargs for append actions must be > 0; if arg ' +\n        'strings are not supplying the value to append, ' +\n        'the append const action may be more appropriate');\n  }\n  if (!!this.constant && this.nargs !== c.OPTIONAL) {\n    throw new Error('nargs must be OPTIONAL to supply const');\n  }\n  Action.call(this, options);\n};\nutil.inherits(ActionAppend, Action);\n\n/*:nodoc:*\n * ActionAppend#call(parser, namespace, values, optionString) -> Void\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Call the action. Save result in namespace object\n **/\nActionAppend.prototype.call = function (parser, namespace, values) {\n  var items = (namespace[this.dest] || []).slice();\n  items.push(values);\n  namespace.set(this.dest, items);\n};\n","/*:nodoc:*\n * class ActionAppendConstant\n *\n * This stores a list, and appends the value specified by\n * the const keyword argument to the list.\n * (Note that the const keyword argument defaults to null.)\n * The 'appendConst' action is typically useful when multiple\n * arguments need to store constants to the same list.\n *\n * This class inherited from [[Action]]\n **/\n\n\n\nvar util = require('util');\n\nvar Action = require('../../action');\n\n/*:nodoc:*\n * new ActionAppendConstant(options)\n * - options (object): options hash see [[Action.new]]\n *\n **/\nvar ActionAppendConstant = module.exports = function ActionAppendConstant(options) {\n  options = options || {};\n  options.nargs = 0;\n  if (typeof options.constant === 'undefined') {\n    throw new Error('constant option is required for appendAction');\n  }\n  Action.call(this, options);\n};\nutil.inherits(ActionAppendConstant, Action);\n\n/*:nodoc:*\n * ActionAppendConstant#call(parser, namespace, values, optionString) -> Void\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Call the action. Save result in namespace object\n **/\nActionAppendConstant.prototype.call = function (parser, namespace) {\n  var items = [].concat(namespace[this.dest] || []);\n  items.push(this.constant);\n  namespace.set(this.dest, items);\n};\n","/*:nodoc:*\n * class ActionCount\n *\n * This counts the number of times a keyword argument occurs.\n * For example, this is useful for increasing verbosity levels\n *\n * This class inherided from [[Action]]\n *\n **/\n\n\nvar util = require('util');\n\nvar Action = require('../action');\n\n/*:nodoc:*\n * new ActionCount(options)\n * - options (object): options hash see [[Action.new]]\n *\n **/\nvar ActionCount = module.exports = function ActionCount(options) {\n  options = options || {};\n  options.nargs = 0;\n\n  Action.call(this, options);\n};\nutil.inherits(ActionCount, Action);\n\n/*:nodoc:*\n * ActionCount#call(parser, namespace, values, optionString) -> Void\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Call the action. Save result in namespace object\n **/\nActionCount.prototype.call = function (parser, namespace) {\n  namespace.set(this.dest, (namespace[this.dest] || 0) + 1);\n};\n","/*:nodoc:*\n * class ActionStore\n *\n * This action just stores the arguments value. This is the default action.\n *\n * This class inherited from [[Action]]\n *\n **/\n\n\nvar util = require('util');\n\nvar Action = require('../action');\n\n// Constants\nvar c = require('../const');\n\n\n/*:nodoc:*\n * new ActionStore(options)\n * - options (object): options hash see [[Action.new]]\n *\n **/\nvar ActionStore = module.exports = function ActionStore(options) {\n  options = options || {};\n  if (this.nargs <= 0) {\n    throw new Error('nargs for store actions must be > 0; if you ' +\n        'have nothing to store, actions such as store ' +\n        'true or store const may be more appropriate');\n\n  }\n  if (typeof this.constant !== 'undefined' && this.nargs !== c.OPTIONAL) {\n    throw new Error('nargs must be OPTIONAL to supply const');\n  }\n  Action.call(this, options);\n};\nutil.inherits(ActionStore, Action);\n\n/*:nodoc:*\n * ActionStore#call(parser, namespace, values, optionString) -> Void\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Call the action. Save result in namespace object\n **/\nActionStore.prototype.call = function (parser, namespace, values) {\n  namespace.set(this.dest, values);\n};\n","/*:nodoc:*\n * class ActionStoreConstant\n *\n * This action stores the value specified by the const keyword argument.\n * (Note that the const keyword argument defaults to the rather unhelpful null.)\n * The 'store_const' action is most commonly used with optional\n * arguments that specify some sort of flag.\n *\n * This class inherited from [[Action]]\n **/\n\n\nvar util = require('util');\n\nvar Action = require('../../action');\n\n/*:nodoc:*\n * new ActionStoreConstant(options)\n * - options (object): options hash see [[Action.new]]\n *\n **/\nvar ActionStoreConstant = module.exports = function ActionStoreConstant(options) {\n  options = options || {};\n  options.nargs = 0;\n  if (typeof options.constant === 'undefined') {\n    throw new Error('constant option is required for storeAction');\n  }\n  Action.call(this, options);\n};\nutil.inherits(ActionStoreConstant, Action);\n\n/*:nodoc:*\n * ActionStoreConstant#call(parser, namespace, values, optionString) -> Void\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Call the action. Save result in namespace object\n **/\nActionStoreConstant.prototype.call = function (parser, namespace) {\n  namespace.set(this.dest, this.constant);\n};\n","/*:nodoc:*\n * class ActionStoreTrue\n *\n * This action store the values True respectively.\n * This isspecial cases of 'storeConst'\n *\n * This class inherited from [[Action]]\n **/\n\n\nvar util = require('util');\n\nvar ActionStoreConstant = require('./constant');\n\n/*:nodoc:*\n * new ActionStoreTrue(options)\n * - options (object): options hash see [[Action.new]]\n *\n **/\nvar ActionStoreTrue = module.exports = function ActionStoreTrue(options) {\n  options = options || {};\n  options.constant = true;\n  options.defaultValue = options.defaultValue !== null ? options.defaultValue : false;\n  ActionStoreConstant.call(this, options);\n};\nutil.inherits(ActionStoreTrue, ActionStoreConstant);\n","/*:nodoc:*\n * class ActionStoreFalse\n *\n * This action store the values False respectively.\n * This is special cases of 'storeConst'\n *\n * This class inherited from [[Action]]\n **/\n\n\n\nvar util = require('util');\n\nvar ActionStoreConstant = require('./constant');\n\n/*:nodoc:*\n * new ActionStoreFalse(options)\n * - options (object): hash of options see [[Action.new]]\n *\n **/\nvar ActionStoreFalse = module.exports = function ActionStoreFalse(options) {\n  options = options || {};\n  options.constant = false;\n  options.defaultValue = options.defaultValue !== null ? options.defaultValue : true;\n  ActionStoreConstant.call(this, options);\n};\nutil.inherits(ActionStoreFalse, ActionStoreConstant);\n","/*:nodoc:*\n * class ActionVersion\n *\n * Support action for printing program version\n * This class inherited from [[Action]]\n **/\n\n\nvar util = require('util');\n\nvar Action = require('../action');\n\n//\n// Constants\n//\nvar c = require('../const');\n\n/*:nodoc:*\n * new ActionVersion(options)\n * - options (object): options hash see [[Action.new]]\n *\n **/\nvar ActionVersion = module.exports = function ActionVersion(options) {\n  options = options || {};\n  options.defaultValue = (options.defaultValue ? options.defaultValue : c.SUPPRESS);\n  options.dest = (options.dest || c.SUPPRESS);\n  options.nargs = 0;\n  this.version = options.version;\n  Action.call(this, options);\n};\nutil.inherits(ActionVersion, Action);\n\n/*:nodoc:*\n * ActionVersion#call(parser, namespace, values, optionString) -> Void\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Print version and exit\n **/\nActionVersion.prototype.call = function (parser) {\n  var version = this.version || parser.version;\n  var formatter = parser._getFormatter();\n  formatter.addText(version);\n  parser.exit(0, formatter.formatHelp());\n};\n","/** internal\n * class ActionSubparsers\n *\n * Support the creation of such sub-commands with the addSubparsers()\n *\n * This class inherited from [[Action]]\n **/\n\n\nvar util    = require('util');\nvar format  = require('util').format;\n\n\nvar Action = require('../action');\n\n// Constants\nvar c = require('../const');\n\n// Errors\nvar argumentErrorHelper = require('../argument/error');\n\n\n/*:nodoc:*\n * new ChoicesPseudoAction(name, help)\n *\n * Create pseudo action for correct help text\n *\n **/\nfunction ChoicesPseudoAction(name, help) {\n  var options = {\n    optionStrings: [],\n    dest: name,\n    help: help\n  };\n\n  Action.call(this, options);\n}\n\nutil.inherits(ChoicesPseudoAction, Action);\n\n/**\n * new ActionSubparsers(options)\n * - options (object): options hash see [[Action.new]]\n *\n **/\nfunction ActionSubparsers(options) {\n  options = options || {};\n  options.dest = options.dest || c.SUPPRESS;\n  options.nargs = c.PARSER;\n\n  this.debug = (options.debug === true);\n\n  this._progPrefix = options.prog;\n  this._parserClass = options.parserClass;\n  this._nameParserMap = {};\n  this._choicesActions = [];\n\n  options.choices = this._nameParserMap;\n  Action.call(this, options);\n}\n\nutil.inherits(ActionSubparsers, Action);\n\n/*:nodoc:*\n * ActionSubparsers#addParser(name, options) -> ArgumentParser\n * - name (string): sub-command name\n * - options (object): see [[ArgumentParser.new]]\n *\n *  Note:\n *  addParser supports an additional aliases option,\n *  which allows multiple strings to refer to the same subparser.\n *  This example, like svn, aliases co as a shorthand for checkout\n *\n **/\nActionSubparsers.prototype.addParser = function (name, options) {\n  var parser;\n\n  var self = this;\n\n  options = options || {};\n\n  options.debug = (this.debug === true);\n\n  // set program from the existing prefix\n  if (!options.prog) {\n    options.prog = this._progPrefix + ' ' + name;\n  }\n\n  var aliases = options.aliases || [];\n\n  // create a pseudo-action to hold the choice help\n  if (!!options.help || typeof options.help === 'string') {\n    var help = options.help;\n    delete options.help;\n\n    var choiceAction = new ChoicesPseudoAction(name, help);\n    this._choicesActions.push(choiceAction);\n  }\n\n  // create the parser and add it to the map\n  parser = new this._parserClass(options);\n  this._nameParserMap[name] = parser;\n\n  // make parser available under aliases also\n  aliases.forEach(function (alias) {\n    self._nameParserMap[alias] = parser;\n  });\n\n  return parser;\n};\n\nActionSubparsers.prototype._getSubactions = function () {\n  return this._choicesActions;\n};\n\n/*:nodoc:*\n * ActionSubparsers#call(parser, namespace, values, optionString) -> Void\n * - parser (ArgumentParser): current parser\n * - namespace (Namespace): namespace for output data\n * - values (Array): parsed values\n * - optionString (Array): input option string(not parsed)\n *\n * Call the action. Parse input aguments\n **/\nActionSubparsers.prototype.call = function (parser, namespace, values) {\n  var parserName = values[0];\n  var argStrings = values.slice(1);\n\n  // set the parser name if requested\n  if (this.dest !== c.SUPPRESS) {\n    namespace[this.dest] = parserName;\n  }\n\n  // select the parser\n  if (this._nameParserMap[parserName]) {\n    parser = this._nameParserMap[parserName];\n  } else {\n    throw argumentErrorHelper(format(\n      'Unknown parser \"%s\" (choices: [%s]).',\n        parserName,\n        Object.keys(this._nameParserMap).join(', ')\n    ));\n  }\n\n  // parse all the remaining options into the namespace\n  parser.parseArgs(argStrings, namespace);\n};\n\nmodule.exports = ActionSubparsers;\n","\n\n\nvar format  = require('util').format;\n\n\nvar ERR_CODE = 'ARGError';\n\n/*:nodoc:*\n * argumentError(argument, message) -> TypeError\n * - argument (Object): action with broken argument\n * - message (String): error message\n *\n * Error format helper. An error from creating or using an argument\n * (optional or positional). The string value of this exception\n * is the message, augmented with information\n * about the argument that caused it.\n *\n * #####Example\n *\n *      var argumentErrorHelper = require('./argument/error');\n *      if (conflictOptionals.length > 0) {\n *        throw argumentErrorHelper(\n *          action,\n *          format('Conflicting option string(s): %s', conflictOptionals.join(', '))\n *        );\n *      }\n *\n **/\nmodule.exports = function (argument, message) {\n  var argumentName = null;\n  var errMessage;\n  var err;\n\n  if (argument.getName) {\n    argumentName = argument.getName();\n  } else {\n    argumentName = '' + argument;\n  }\n\n  if (!argumentName) {\n    errMessage = message;\n  } else {\n    errMessage = format('argument \"%s\": %s', argumentName, message);\n  }\n\n  err = new TypeError(errMessage);\n  err.code = ERR_CODE;\n  return err;\n};\n","/** internal\n * class ArgumentGroup\n *\n * Group arguments.\n * By default, ArgumentParser groups command-line arguments\n * into positional arguments and optional arguments\n * when displaying help messages. When there is a better\n * conceptual grouping of arguments than this default one,\n * appropriate groups can be created using the addArgumentGroup() method\n *\n * This class inherited from [[ArgumentContainer]]\n **/\n\n\nvar util = require('util');\n\nvar ActionContainer = require('../action_container');\n\n\n/**\n * new ArgumentGroup(container, options)\n * - container (object): main container\n * - options (object): hash of group options\n *\n * #### options\n * - **prefixChars**  group name prefix\n * - **argumentDefault**  default argument value\n * - **title**  group title\n * - **description** group description\n *\n **/\nvar ArgumentGroup = module.exports = function ArgumentGroup(container, options) {\n\n  options = options || {};\n\n  // add any missing keyword arguments by checking the container\n  options.conflictHandler = (options.conflictHandler || container.conflictHandler);\n  options.prefixChars = (options.prefixChars || container.prefixChars);\n  options.argumentDefault = (options.argumentDefault || container.argumentDefault);\n\n  ActionContainer.call(this, options);\n\n  // group attributes\n  this.title = options.title;\n  this._groupActions = [];\n\n  // share most attributes with the container\n  this._container = container;\n  this._registries = container._registries;\n  this._actions = container._actions;\n  this._optionStringActions = container._optionStringActions;\n  this._defaults = container._defaults;\n  this._hasNegativeNumberOptionals = container._hasNegativeNumberOptionals;\n  this._mutuallyExclusiveGroups = container._mutuallyExclusiveGroups;\n};\nutil.inherits(ArgumentGroup, ActionContainer);\n\n\nArgumentGroup.prototype._addAction = function (action) {\n  // Parent add action\n  action = ActionContainer.prototype._addAction.call(this, action);\n  this._groupActions.push(action);\n  return action;\n};\n\n\nArgumentGroup.prototype._removeAction = function (action) {\n  // Parent remove action\n  ActionContainer.prototype._removeAction.call(this, action);\n  var actionIndex = this._groupActions.indexOf(action);\n  if (actionIndex >= 0) {\n    this._groupActions.splice(actionIndex, 1);\n  }\n};\n\n","/** internal\n * class MutuallyExclusiveGroup\n *\n * Group arguments.\n * By default, ArgumentParser groups command-line arguments\n * into positional arguments and optional arguments\n * when displaying help messages. When there is a better\n * conceptual grouping of arguments than this default one,\n * appropriate groups can be created using the addArgumentGroup() method\n *\n * This class inherited from [[ArgumentContainer]]\n **/\n\n\nvar util = require('util');\n\nvar ArgumentGroup = require('./group');\n\n/**\n * new MutuallyExclusiveGroup(container, options)\n * - container (object): main container\n * - options (object): options.required -> true/false\n *\n * `required` could be an argument itself, but making it a property of\n * the options argument is more consistent with the JS adaptation of the Python)\n **/\nvar MutuallyExclusiveGroup = module.exports = function MutuallyExclusiveGroup(container, options) {\n  var required;\n  options = options || {};\n  required = options.required || false;\n  ArgumentGroup.call(this, container);\n  this.required = required;\n\n};\nutil.inherits(MutuallyExclusiveGroup, ArgumentGroup);\n\n\nMutuallyExclusiveGroup.prototype._addAction = function (action) {\n  var msg;\n  if (action.required) {\n    msg = 'mutually exclusive arguments must be optional';\n    throw new Error(msg);\n  }\n  action = this._container._addAction(action);\n  this._groupActions.push(action);\n  return action;\n};\n\n\nMutuallyExclusiveGroup.prototype._removeAction = function (action) {\n  this._container._removeAction(action);\n  this._groupActions.remove(action);\n};\n\n","/**\n * class HelpFormatter\n *\n * Formatter for generating usage messages and argument help strings. Only the\n * name of this class is considered a public API. All the methods provided by\n * the class are considered an implementation detail.\n *\n * Do not call in your code, use this class only for inherits your own forvatter\n *\n * ToDo add [additonal formatters][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#formatter-class\n **/\n\n\nvar sprintf = require('sprintf-js').sprintf;\n\n// Constants\nvar c = require('../const');\n\nvar $$ = require('../utils');\n\n\n/*:nodoc:* internal\n * new Support(parent, heding)\n * - parent (object): parent section\n * - heading (string): header string\n *\n **/\nfunction Section(parent, heading) {\n  this._parent = parent;\n  this._heading = heading;\n  this._items = [];\n}\n\n/*:nodoc:* internal\n * Section#addItem(callback) -> Void\n * - callback (array): tuple with function and args\n *\n * Add function for single element\n **/\nSection.prototype.addItem = function (callback) {\n  this._items.push(callback);\n};\n\n/*:nodoc:* internal\n * Section#formatHelp(formatter) -> string\n * - formatter (HelpFormatter): current formatter\n *\n * Form help section string\n *\n **/\nSection.prototype.formatHelp = function (formatter) {\n  var itemHelp, heading;\n\n  // format the indented section\n  if (this._parent) {\n    formatter._indent();\n  }\n\n  itemHelp = this._items.map(function (item) {\n    var obj, func, args;\n\n    obj = formatter;\n    func = item[0];\n    args = item[1];\n    return func.apply(obj, args);\n  });\n  itemHelp = formatter._joinParts(itemHelp);\n\n  if (this._parent) {\n    formatter._dedent();\n  }\n\n  // return nothing if the section was empty\n  if (!itemHelp) {\n    return '';\n  }\n\n  // add the heading if the section was non-empty\n  heading = '';\n  if (this._heading && this._heading !== c.SUPPRESS) {\n    var currentIndent = formatter.currentIndent;\n    heading = $$.repeat(' ', currentIndent) + this._heading + ':' + c.EOL;\n  }\n\n  // join the section-initialize newline, the heading and the help\n  return formatter._joinParts([ c.EOL, heading, itemHelp, c.EOL ]);\n};\n\n/**\n * new HelpFormatter(options)\n *\n * #### Options:\n * - `prog`: program name\n * - `indentIncriment`: indent step, default value 2\n * - `maxHelpPosition`: max help position, default value = 24\n * - `width`: line width\n *\n **/\nvar HelpFormatter = module.exports = function HelpFormatter(options) {\n  options = options || {};\n\n  this._prog = options.prog;\n\n  this._maxHelpPosition = options.maxHelpPosition || 24;\n  this._width = (options.width || ((process.env.COLUMNS || 80) - 2));\n\n  this._currentIndent = 0;\n  this._indentIncriment = options.indentIncriment || 2;\n  this._level = 0;\n  this._actionMaxLength = 0;\n\n  this._rootSection = new Section(null);\n  this._currentSection = this._rootSection;\n\n  this._whitespaceMatcher = new RegExp('\\\\s+', 'g');\n  this._longBreakMatcher = new RegExp(c.EOL + c.EOL + c.EOL + '+', 'g');\n};\n\nHelpFormatter.prototype._indent = function () {\n  this._currentIndent += this._indentIncriment;\n  this._level += 1;\n};\n\nHelpFormatter.prototype._dedent = function () {\n  this._currentIndent -= this._indentIncriment;\n  this._level -= 1;\n  if (this._currentIndent < 0) {\n    throw new Error('Indent decreased below 0.');\n  }\n};\n\nHelpFormatter.prototype._addItem = function (func, args) {\n  this._currentSection.addItem([ func, args ]);\n};\n\n//\n// Message building methods\n//\n\n/**\n * HelpFormatter#startSection(heading) -> Void\n * - heading (string): header string\n *\n * Start new help section\n *\n * See alse [code example][1]\n *\n * ##### Example\n *\n *      formatter.startSection(actionGroup.title);\n *      formatter.addText(actionGroup.description);\n *      formatter.addArguments(actionGroup._groupActions);\n *      formatter.endSection();\n *\n **/\nHelpFormatter.prototype.startSection = function (heading) {\n  this._indent();\n  var section = new Section(this._currentSection, heading);\n  var func = section.formatHelp.bind(section);\n  this._addItem(func, [ this ]);\n  this._currentSection = section;\n};\n\n/**\n * HelpFormatter#endSection -> Void\n *\n * End help section\n *\n * ##### Example\n *\n *      formatter.startSection(actionGroup.title);\n *      formatter.addText(actionGroup.description);\n *      formatter.addArguments(actionGroup._groupActions);\n *      formatter.endSection();\n **/\nHelpFormatter.prototype.endSection = function () {\n  this._currentSection = this._currentSection._parent;\n  this._dedent();\n};\n\n/**\n * HelpFormatter#addText(text) -> Void\n * - text (string): plain text\n *\n * Add plain text into current section\n *\n * ##### Example\n *\n *      formatter.startSection(actionGroup.title);\n *      formatter.addText(actionGroup.description);\n *      formatter.addArguments(actionGroup._groupActions);\n *      formatter.endSection();\n *\n **/\nHelpFormatter.prototype.addText = function (text) {\n  if (text && text !== c.SUPPRESS) {\n    this._addItem(this._formatText, [ text ]);\n  }\n};\n\n/**\n * HelpFormatter#addUsage(usage, actions, groups, prefix) -> Void\n * - usage (string): usage text\n * - actions (array): actions list\n * - groups (array): groups list\n * - prefix (string): usage prefix\n *\n * Add usage data into current section\n *\n * ##### Example\n *\n *      formatter.addUsage(this.usage, this._actions, []);\n *      return formatter.formatHelp();\n *\n **/\nHelpFormatter.prototype.addUsage = function (usage, actions, groups, prefix) {\n  if (usage !== c.SUPPRESS) {\n    this._addItem(this._formatUsage, [ usage, actions, groups, prefix ]);\n  }\n};\n\n/**\n * HelpFormatter#addArgument(action) -> Void\n * - action (object): action\n *\n * Add argument into current section\n *\n * Single variant of [[HelpFormatter#addArguments]]\n **/\nHelpFormatter.prototype.addArgument = function (action) {\n  if (action.help !== c.SUPPRESS) {\n    var self = this;\n\n    // find all invocations\n    var invocations = [ this._formatActionInvocation(action) ];\n    var invocationLength = invocations[0].length;\n\n    var actionLength;\n\n    if (action._getSubactions) {\n      this._indent();\n      action._getSubactions().forEach(function (subaction) {\n\n        var invocationNew = self._formatActionInvocation(subaction);\n        invocations.push(invocationNew);\n        invocationLength = Math.max(invocationLength, invocationNew.length);\n\n      });\n      this._dedent();\n    }\n\n    // update the maximum item length\n    actionLength = invocationLength + this._currentIndent;\n    this._actionMaxLength = Math.max(this._actionMaxLength, actionLength);\n\n    // add the item to the list\n    this._addItem(this._formatAction, [ action ]);\n  }\n};\n\n/**\n * HelpFormatter#addArguments(actions) -> Void\n * - actions (array): actions list\n *\n * Mass add arguments into current section\n *\n * ##### Example\n *\n *      formatter.startSection(actionGroup.title);\n *      formatter.addText(actionGroup.description);\n *      formatter.addArguments(actionGroup._groupActions);\n *      formatter.endSection();\n *\n **/\nHelpFormatter.prototype.addArguments = function (actions) {\n  var self = this;\n  actions.forEach(function (action) {\n    self.addArgument(action);\n  });\n};\n\n//\n// Help-formatting methods\n//\n\n/**\n * HelpFormatter#formatHelp -> string\n *\n * Format help\n *\n * ##### Example\n *\n *      formatter.addText(this.epilog);\n *      return formatter.formatHelp();\n *\n **/\nHelpFormatter.prototype.formatHelp = function () {\n  var help = this._rootSection.formatHelp(this);\n  if (help) {\n    help = help.replace(this._longBreakMatcher, c.EOL + c.EOL);\n    help = $$.trimChars(help, c.EOL) + c.EOL;\n  }\n  return help;\n};\n\nHelpFormatter.prototype._joinParts = function (partStrings) {\n  return partStrings.filter(function (part) {\n    return (part && part !== c.SUPPRESS);\n  }).join('');\n};\n\nHelpFormatter.prototype._formatUsage = function (usage, actions, groups, prefix) {\n  if (!prefix && typeof prefix !== 'string') {\n    prefix = 'usage: ';\n  }\n\n  actions = actions || [];\n  groups = groups || [];\n\n\n  // if usage is specified, use that\n  if (usage) {\n    usage = sprintf(usage, { prog: this._prog });\n\n    // if no optionals or positionals are available, usage is just prog\n  } else if (!usage && actions.length === 0) {\n    usage = this._prog;\n\n    // if optionals and positionals are available, calculate usage\n  } else if (!usage) {\n    var prog = this._prog;\n    var optionals = [];\n    var positionals = [];\n    var actionUsage;\n    var textWidth;\n\n    // split optionals from positionals\n    actions.forEach(function (action) {\n      if (action.isOptional()) {\n        optionals.push(action);\n      } else {\n        positionals.push(action);\n      }\n    });\n\n    // build full usage string\n    actionUsage = this._formatActionsUsage([].concat(optionals, positionals), groups);\n    usage = [ prog, actionUsage ].join(' ');\n\n    // wrap the usage parts if it's too long\n    textWidth = this._width - this._currentIndent;\n    if ((prefix.length + usage.length) > textWidth) {\n\n      // break usage into wrappable parts\n      var regexpPart = new RegExp('\\\\(.*?\\\\)+|\\\\[.*?\\\\]+|\\\\S+', 'g');\n      var optionalUsage = this._formatActionsUsage(optionals, groups);\n      var positionalUsage = this._formatActionsUsage(positionals, groups);\n\n\n      var optionalParts = optionalUsage.match(regexpPart);\n      var positionalParts = positionalUsage.match(regexpPart) || [];\n\n      if (optionalParts.join(' ') !== optionalUsage) {\n        throw new Error('assert \"optionalParts.join(\\' \\') === optionalUsage\"');\n      }\n      if (positionalParts.join(' ') !== positionalUsage) {\n        throw new Error('assert \"positionalParts.join(\\' \\') === positionalUsage\"');\n      }\n\n      // helper for wrapping lines\n      /*eslint-disable func-style*/ // node 0.10 compat\n      var _getLines = function (parts, indent, prefix) {\n        var lines = [];\n        var line = [];\n\n        var lineLength = prefix ? prefix.length - 1 : indent.length - 1;\n\n        parts.forEach(function (part) {\n          if (lineLength + 1 + part.length > textWidth) {\n            lines.push(indent + line.join(' '));\n            line = [];\n            lineLength = indent.length - 1;\n          }\n          line.push(part);\n          lineLength += part.length + 1;\n        });\n\n        if (line) {\n          lines.push(indent + line.join(' '));\n        }\n        if (prefix) {\n          lines[0] = lines[0].substr(indent.length);\n        }\n        return lines;\n      };\n\n      var lines, indent, parts;\n      // if prog is short, follow it with optionals or positionals\n      if (prefix.length + prog.length <= 0.75 * textWidth) {\n        indent = $$.repeat(' ', (prefix.length + prog.length + 1));\n        if (optionalParts) {\n          lines = [].concat(\n            _getLines([ prog ].concat(optionalParts), indent, prefix),\n            _getLines(positionalParts, indent)\n          );\n        } else if (positionalParts) {\n          lines = _getLines([ prog ].concat(positionalParts), indent, prefix);\n        } else {\n          lines = [ prog ];\n        }\n\n        // if prog is long, put it on its own line\n      } else {\n        indent = $$.repeat(' ', prefix.length);\n        parts = optionalParts.concat(positionalParts);\n        lines = _getLines(parts, indent);\n        if (lines.length > 1) {\n          lines = [].concat(\n            _getLines(optionalParts, indent),\n            _getLines(positionalParts, indent)\n          );\n        }\n        lines = [ prog ].concat(lines);\n      }\n      // join lines into usage\n      usage = lines.join(c.EOL);\n    }\n  }\n\n  // prefix with 'usage:'\n  return prefix + usage + c.EOL + c.EOL;\n};\n\nHelpFormatter.prototype._formatActionsUsage = function (actions, groups) {\n  // find group indices and identify actions in groups\n  var groupActions = [];\n  var inserts = [];\n  var self = this;\n\n  groups.forEach(function (group) {\n    var end;\n    var i;\n\n    var start = actions.indexOf(group._groupActions[0]);\n    if (start >= 0) {\n      end = start + group._groupActions.length;\n\n      //if (actions.slice(start, end) === group._groupActions) {\n      if ($$.arrayEqual(actions.slice(start, end), group._groupActions)) {\n        group._groupActions.forEach(function (action) {\n          groupActions.push(action);\n        });\n\n        if (!group.required) {\n          if (inserts[start]) {\n            inserts[start] += ' [';\n          } else {\n            inserts[start] = '[';\n          }\n          inserts[end] = ']';\n        } else {\n          if (inserts[start]) {\n            inserts[start] += ' (';\n          } else {\n            inserts[start] = '(';\n          }\n          inserts[end] = ')';\n        }\n        for (i = start + 1; i < end; i += 1) {\n          inserts[i] = '|';\n        }\n      }\n    }\n  });\n\n  // collect all actions format strings\n  var parts = [];\n\n  actions.forEach(function (action, actionIndex) {\n    var part;\n    var optionString;\n    var argsDefault;\n    var argsString;\n\n    // suppressed arguments are marked with None\n    // remove | separators for suppressed arguments\n    if (action.help === c.SUPPRESS) {\n      parts.push(null);\n      if (inserts[actionIndex] === '|') {\n        inserts.splice(actionIndex, actionIndex);\n      } else if (inserts[actionIndex + 1] === '|') {\n        inserts.splice(actionIndex + 1, actionIndex + 1);\n      }\n\n      // produce all arg strings\n    } else if (!action.isOptional()) {\n      part = self._formatArgs(action, action.dest);\n\n      // if it's in a group, strip the outer []\n      if (groupActions.indexOf(action) >= 0) {\n        if (part[0] === '[' && part[part.length - 1] === ']') {\n          part = part.slice(1, -1);\n        }\n      }\n      // add the action string to the list\n      parts.push(part);\n\n    // produce the first way to invoke the option in brackets\n    } else {\n      optionString = action.optionStrings[0];\n\n      // if the Optional doesn't take a value, format is: -s or --long\n      if (action.nargs === 0) {\n        part = '' + optionString;\n\n      // if the Optional takes a value, format is: -s ARGS or --long ARGS\n      } else {\n        argsDefault = action.dest.toUpperCase();\n        argsString = self._formatArgs(action, argsDefault);\n        part = optionString + ' ' + argsString;\n      }\n      // make it look optional if it's not required or in a group\n      if (!action.required && groupActions.indexOf(action) < 0) {\n        part = '[' + part + ']';\n      }\n      // add the action string to the list\n      parts.push(part);\n    }\n  });\n\n  // insert things at the necessary indices\n  for (var i = inserts.length - 1; i >= 0; --i) {\n    if (inserts[i] !== null) {\n      parts.splice(i, 0, inserts[i]);\n    }\n  }\n\n  // join all the action items with spaces\n  var text = parts.filter(function (part) {\n    return !!part;\n  }).join(' ');\n\n  // clean up separators for mutually exclusive groups\n  text = text.replace(/([\\[(]) /g, '$1'); // remove spaces\n  text = text.replace(/ ([\\])])/g, '$1');\n  text = text.replace(/\\[ *\\]/g, ''); // remove empty groups\n  text = text.replace(/\\( *\\)/g, '');\n  text = text.replace(/\\(([^|]*)\\)/g, '$1'); // remove () from single action groups\n\n  text = text.trim();\n\n  // return the text\n  return text;\n};\n\nHelpFormatter.prototype._formatText = function (text) {\n  text = sprintf(text, { prog: this._prog });\n  var textWidth = this._width - this._currentIndent;\n  var indentIncriment = $$.repeat(' ', this._currentIndent);\n  return this._fillText(text, textWidth, indentIncriment) + c.EOL + c.EOL;\n};\n\nHelpFormatter.prototype._formatAction = function (action) {\n  var self = this;\n\n  var helpText;\n  var helpLines;\n  var parts;\n  var indentFirst;\n\n  // determine the required width and the entry label\n  var helpPosition = Math.min(this._actionMaxLength + 2, this._maxHelpPosition);\n  var helpWidth = this._width - helpPosition;\n  var actionWidth = helpPosition - this._currentIndent - 2;\n  var actionHeader = this._formatActionInvocation(action);\n\n  // no help; start on same line and add a final newline\n  if (!action.help) {\n    actionHeader = $$.repeat(' ', this._currentIndent) + actionHeader + c.EOL;\n\n  // short action name; start on the same line and pad two spaces\n  } else if (actionHeader.length <= actionWidth) {\n    actionHeader = $$.repeat(' ', this._currentIndent) +\n        actionHeader +\n        '  ' +\n        $$.repeat(' ', actionWidth - actionHeader.length);\n    indentFirst = 0;\n\n  // long action name; start on the next line\n  } else {\n    actionHeader = $$.repeat(' ', this._currentIndent) + actionHeader + c.EOL;\n    indentFirst = helpPosition;\n  }\n\n  // collect the pieces of the action help\n  parts = [ actionHeader ];\n\n  // if there was help for the action, add lines of help text\n  if (action.help) {\n    helpText = this._expandHelp(action);\n    helpLines = this._splitLines(helpText, helpWidth);\n    parts.push($$.repeat(' ', indentFirst) + helpLines[0] + c.EOL);\n    helpLines.slice(1).forEach(function (line) {\n      parts.push($$.repeat(' ', helpPosition) + line + c.EOL);\n    });\n\n  // or add a newline if the description doesn't end with one\n  } else if (actionHeader.charAt(actionHeader.length - 1) !== c.EOL) {\n    parts.push(c.EOL);\n  }\n  // if there are any sub-actions, add their help as well\n  if (action._getSubactions) {\n    this._indent();\n    action._getSubactions().forEach(function (subaction) {\n      parts.push(self._formatAction(subaction));\n    });\n    this._dedent();\n  }\n  // return a single string\n  return this._joinParts(parts);\n};\n\nHelpFormatter.prototype._formatActionInvocation = function (action) {\n  if (!action.isOptional()) {\n    var format_func = this._metavarFormatter(action, action.dest);\n    var metavars = format_func(1);\n    return metavars[0];\n  }\n\n  var parts = [];\n  var argsDefault;\n  var argsString;\n\n  // if the Optional doesn't take a value, format is: -s, --long\n  if (action.nargs === 0) {\n    parts = parts.concat(action.optionStrings);\n\n  // if the Optional takes a value, format is: -s ARGS, --long ARGS\n  } else {\n    argsDefault = action.dest.toUpperCase();\n    argsString = this._formatArgs(action, argsDefault);\n    action.optionStrings.forEach(function (optionString) {\n      parts.push(optionString + ' ' + argsString);\n    });\n  }\n  return parts.join(', ');\n};\n\nHelpFormatter.prototype._metavarFormatter = function (action, metavarDefault) {\n  var result;\n\n  if (action.metavar || action.metavar === '') {\n    result = action.metavar;\n  } else if (action.choices) {\n    var choices = action.choices;\n\n    if (typeof choices === 'string') {\n      choices = choices.split('').join(', ');\n    } else if (Array.isArray(choices)) {\n      choices = choices.join(',');\n    } else {\n      choices = Object.keys(choices).join(',');\n    }\n    result = '{' + choices + '}';\n  } else {\n    result = metavarDefault;\n  }\n\n  return function (size) {\n    if (Array.isArray(result)) {\n      return result;\n    }\n\n    var metavars = [];\n    for (var i = 0; i < size; i += 1) {\n      metavars.push(result);\n    }\n    return metavars;\n  };\n};\n\nHelpFormatter.prototype._formatArgs = function (action, metavarDefault) {\n  var result;\n  var metavars;\n\n  var buildMetavar = this._metavarFormatter(action, metavarDefault);\n\n  switch (action.nargs) {\n    /*eslint-disable no-undefined*/\n    case undefined:\n    case null:\n      metavars = buildMetavar(1);\n      result = '' + metavars[0];\n      break;\n    case c.OPTIONAL:\n      metavars = buildMetavar(1);\n      result = '[' + metavars[0] + ']';\n      break;\n    case c.ZERO_OR_MORE:\n      metavars = buildMetavar(2);\n      result = '[' + metavars[0] + ' [' + metavars[1] + ' ...]]';\n      break;\n    case c.ONE_OR_MORE:\n      metavars = buildMetavar(2);\n      result = '' + metavars[0] + ' [' + metavars[1] + ' ...]';\n      break;\n    case c.REMAINDER:\n      result = '...';\n      break;\n    case c.PARSER:\n      metavars = buildMetavar(1);\n      result = metavars[0] + ' ...';\n      break;\n    default:\n      metavars = buildMetavar(action.nargs);\n      result = metavars.join(' ');\n  }\n  return result;\n};\n\nHelpFormatter.prototype._expandHelp = function (action) {\n  var params = { prog: this._prog };\n\n  Object.keys(action).forEach(function (actionProperty) {\n    var actionValue = action[actionProperty];\n\n    if (actionValue !== c.SUPPRESS) {\n      params[actionProperty] = actionValue;\n    }\n  });\n\n  if (params.choices) {\n    if (typeof params.choices === 'string') {\n      params.choices = params.choices.split('').join(', ');\n    } else if (Array.isArray(params.choices)) {\n      params.choices = params.choices.join(', ');\n    } else {\n      params.choices = Object.keys(params.choices).join(', ');\n    }\n  }\n\n  return sprintf(this._getHelpString(action), params);\n};\n\nHelpFormatter.prototype._splitLines = function (text, width) {\n  var lines = [];\n  var delimiters = [ ' ', '.', ',', '!', '?' ];\n  var re = new RegExp('[' + delimiters.join('') + '][^' + delimiters.join('') + ']*$');\n\n  text = text.replace(/[\\n\\|\\t]/g, ' ');\n\n  text = text.trim();\n  text = text.replace(this._whitespaceMatcher, ' ');\n\n  // Wraps the single paragraph in text (a string) so every line\n  // is at most width characters long.\n  text.split(c.EOL).forEach(function (line) {\n    if (width >= line.length) {\n      lines.push(line);\n      return;\n    }\n\n    var wrapStart = 0;\n    var wrapEnd = width;\n    var delimiterIndex = 0;\n    while (wrapEnd <= line.length) {\n      if (wrapEnd !== line.length && delimiters.indexOf(line[wrapEnd] < -1)) {\n        delimiterIndex = (re.exec(line.substring(wrapStart, wrapEnd)) || {}).index;\n        wrapEnd = wrapStart + delimiterIndex + 1;\n      }\n      lines.push(line.substring(wrapStart, wrapEnd));\n      wrapStart = wrapEnd;\n      wrapEnd += width;\n    }\n    if (wrapStart < line.length) {\n      lines.push(line.substring(wrapStart, wrapEnd));\n    }\n  });\n\n  return lines;\n};\n\nHelpFormatter.prototype._fillText = function (text, width, indent) {\n  var lines = this._splitLines(text, width);\n  lines = lines.map(function (line) {\n    return indent + line;\n  });\n  return lines.join(c.EOL);\n};\n\nHelpFormatter.prototype._getHelpString = function (action) {\n  return action.help;\n};\n","/**\n * class Namespace\n *\n * Simple object for storing attributes. Implements equality by attribute names\n * and values, and provides a simple string representation.\n *\n * See also [original guide][1]\n *\n * [1]:http://docs.python.org/dev/library/argparse.html#the-namespace-object\n **/\n\n\nvar $$ = require('./utils');\n\n/**\n * new Namespace(options)\n * - options(object): predefined propertis for result object\n *\n **/\nvar Namespace = module.exports = function Namespace(options) {\n  $$.extend(this, options);\n};\n\n/**\n * Namespace#isset(key) -> Boolean\n * - key (string|number): property name\n *\n * Tells whenever `namespace` contains given `key` or not.\n **/\nNamespace.prototype.isset = function (key) {\n  return $$.has(this, key);\n};\n\n/**\n * Namespace#set(key, value) -> self\n * -key (string|number|object): propery name\n * -value (mixed): new property value\n *\n * Set the property named key with value.\n * If key object then set all key properties to namespace object\n **/\nNamespace.prototype.set = function (key, value) {\n  if (typeof (key) === 'object') {\n    $$.extend(this, key);\n  } else {\n    this[key] = value;\n  }\n  return this;\n};\n\n/**\n * Namespace#get(key, defaultValue) -> mixed\n * - key (string|number): property name\n * - defaultValue (mixed): default value\n *\n * Return the property key or defaulValue if not set\n **/\nNamespace.prototype.get = function (key, defaultValue) {\n  return !this[key] ? defaultValue : this[key];\n};\n\n/**\n * Namespace#unset(key, defaultValue) -> mixed\n * - key (string|number): property name\n * - defaultValue (mixed): default value\n *\n * Return data[key](and delete it) or defaultValue\n **/\nNamespace.prototype.unset = function (key, defaultValue) {\n  var value = this[key];\n  if (value !== null) {\n    delete this[key];\n    return value;\n  }\n  return defaultValue;\n};\n","\n\nvar util    = require('util');\n\n// Constants\nvar c = require('../const');\n\nvar $$ = require('../utils');\nvar HelpFormatter = require('./formatter.js');\n\n/**\n * new RawDescriptionHelpFormatter(options)\n * new ArgumentParser({formatterClass: argparse.RawDescriptionHelpFormatter, ...})\n *\n * Help message formatter which adds default values to argument help.\n *\n * Only the name of this class is considered a public API. All the methods\n * provided by the class are considered an implementation detail.\n **/\n\nfunction ArgumentDefaultsHelpFormatter(options) {\n  HelpFormatter.call(this, options);\n}\n\nutil.inherits(ArgumentDefaultsHelpFormatter, HelpFormatter);\n\nArgumentDefaultsHelpFormatter.prototype._getHelpString = function (action) {\n  var help = action.help;\n  if (action.help.indexOf('%(defaultValue)s') === -1) {\n    if (action.defaultValue !== c.SUPPRESS) {\n      var defaulting_nargs = [ c.OPTIONAL, c.ZERO_OR_MORE ];\n      if (action.isOptional() || (defaulting_nargs.indexOf(action.nargs) >= 0)) {\n        help += ' (default: %(defaultValue)s)';\n      }\n    }\n  }\n  return help;\n};\n\nmodule.exports.ArgumentDefaultsHelpFormatter = ArgumentDefaultsHelpFormatter;\n\n/**\n * new RawDescriptionHelpFormatter(options)\n * new ArgumentParser({formatterClass: argparse.RawDescriptionHelpFormatter, ...})\n *\n * Help message formatter which retains any formatting in descriptions.\n *\n * Only the name of this class is considered a public API. All the methods\n * provided by the class are considered an implementation detail.\n **/\n\nfunction RawDescriptionHelpFormatter(options) {\n  HelpFormatter.call(this, options);\n}\n\nutil.inherits(RawDescriptionHelpFormatter, HelpFormatter);\n\nRawDescriptionHelpFormatter.prototype._fillText = function (text, width, indent) {\n  var lines = text.split('\\n');\n  lines = lines.map(function (line) {\n    return $$.trimEnd(indent + line);\n  });\n  return lines.join('\\n');\n};\nmodule.exports.RawDescriptionHelpFormatter = RawDescriptionHelpFormatter;\n\n/**\n * new RawTextHelpFormatter(options)\n * new ArgumentParser({formatterClass: argparse.RawTextHelpFormatter, ...})\n *\n * Help message formatter which retains formatting of all help text.\n *\n * Only the name of this class is considered a public API. All the methods\n * provided by the class are considered an implementation detail.\n **/\n\nfunction RawTextHelpFormatter(options) {\n  RawDescriptionHelpFormatter.call(this, options);\n}\n\nutil.inherits(RawTextHelpFormatter, RawDescriptionHelpFormatter);\n\nRawTextHelpFormatter.prototype._splitLines = function (text) {\n  return text.split('\\n');\n};\n\nmodule.exports.RawTextHelpFormatter = RawTextHelpFormatter;\n"]}